diff --git a/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c b/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c
--- a/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c	2015-09-24 17:47:25.000000000 +0200
@@ -63,8 +63,8 @@
 		cmd->duplex = port->full_duplex == 1 ?
 						     DUPLEX_FULL : DUPLEX_HALF;
 	} else {
-		speed = SPEED_UNKNOWN;
-		cmd->duplex = DUPLEX_UNKNOWN;
+		speed = ~0;
+		cmd->duplex = -1;
 	}
 	ethtool_cmd_speed_set(cmd, speed);
 
@@ -278,5 +278,5 @@
 
 void ehea_set_ethtool_ops(struct net_device *netdev)
 {
-	netdev->ethtool_ops = &ehea_ethtool_ops;
+	SET_ETHTOOL_OPS(netdev, &ehea_ethtool_ops);
 }
diff --git a/drivers/net/ethernet/ibm/ehea/ehea_main.c b/drivers/net/ethernet/ibm/ehea/ehea_main.c
--- a/drivers/net/ethernet/ibm/ehea/ehea_main.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/ehea/ehea_main.c	2015-09-24 17:47:25.000000000 +0200
@@ -28,7 +28,6 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include <linux/device.h>
 #include <linux/in.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
@@ -99,32 +98,21 @@
 static struct ehea_bcmc_reg_array ehea_bcmc_regs;
 
 
-static int ehea_probe_adapter(struct platform_device *dev);
+static int ehea_probe_adapter(struct platform_device *dev,
+			      const struct of_device_id *id);
 
 static int ehea_remove(struct platform_device *dev);
 
-static const struct of_device_id ehea_module_device_table[] = {
-	{
-		.name = "lhea",
-		.compatible = "IBM,lhea",
-	},
-	{
-		.type = "network",
-		.compatible = "IBM,lhea-ethernet",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, ehea_module_device_table);
-
-static const struct of_device_id ehea_device_table[] = {
+static struct of_device_id ehea_device_table[] = {
 	{
 		.name = "lhea",
 		.compatible = "IBM,lhea",
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, ehea_device_table);
 
-static struct platform_driver ehea_driver = {
+static struct of_platform_driver ehea_driver = {
 	.driver = {
 		.name = "ehea",
 		.owner = THIS_MODULE,
@@ -491,7 +479,7 @@
 		skb_arr[index] = skb;
 		tmp_addr = ehea_map_vaddr(skb->data);
 		if (tmp_addr == -1) {
-			dev_consume_skb_any(skb);
+			dev_kfree_skb(skb);
 			q_skba->os_skbs = fill_wqes - i;
 			ret = 0;
 			break;
@@ -857,7 +845,7 @@
 
 			index = EHEA_BMASK_GET(EHEA_WR_ID_INDEX, cqe->wr_id);
 			skb = pr->sq_skba.arr[index];
-			dev_consume_skb_any(skb);
+			dev_kfree_skb(skb);
 			pr->sq_skba.arr[index] = NULL;
 		}
 
@@ -1169,15 +1157,16 @@
 	ec = EHEA_BMASK_GET(NEQE_EVENT_CODE, eqe);
 	portnum = EHEA_BMASK_GET(NEQE_PORTNUM, eqe);
 	port = ehea_get_port(adapter, portnum);
-	if (!port) {
-		netdev_err(NULL, "unknown portnum %x\n", portnum);
-		return;
-	}
 	dev = port->netdev;
 
 	switch (ec) {
 	case EHEA_EC_PORTSTATE_CHG:	/* port state change */
 
+		if (!port) {
+			netdev_err(dev, "unknown portnum %x\n", portnum);
+			break;
+		}
+
 		if (EHEA_BMASK_GET(NEQE_PORT_UP, eqe)) {
 			if (!netif_carrier_ok(dev)) {
 				ret = ehea_sense_port_attr(port);
@@ -1297,7 +1286,7 @@
 
 	ret = ibmebus_request_irq(port->qp_eq->attr.ist1,
 				  ehea_qp_aff_irq_handler,
-				  0, port->int_aff_name, port);
+				  IRQF_DISABLED, port->int_aff_name, port);
 	if (ret) {
 		netdev_err(dev, "failed registering irq for qp_aff_irq_handler:ist=%X\n",
 			   port->qp_eq->attr.ist1);
@@ -1315,7 +1304,8 @@
 			 "%s-queue%d", dev->name, i);
 		ret = ibmebus_request_irq(pr->eq->attr.ist1,
 					  ehea_recv_irq_handler,
-					  0, pr->int_send_name, pr);
+					  IRQF_DISABLED, pr->int_send_name,
+					  pr);
 		if (ret) {
 			netdev_err(dev, "failed registering irq for ehea_queue port_res_nr:%d, ist=%X\n",
 				   i, pr->eq->attr.ist1);
@@ -1981,6 +1971,14 @@
 	ehea_update_bcmc_registrations();
 }
 
+static int ehea_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if ((new_mtu < 68) || (new_mtu > EHEA_MAX_PACKET_SIZE))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
 static void xmit_common(struct sk_buff *skb, struct ehea_swqe *swqe)
 {
 	swqe->tx_control |= EHEA_SWQE_IMM_DATA_PRESENT | EHEA_SWQE_CRC;
@@ -2036,7 +2034,7 @@
 		skb_copy_bits(skb, 0, imm_data, skb->len);
 
 	swqe->immediate_data_length = skb->len;
-	dev_consume_skb_any(skb);
+	dev_kfree_skb(skb);
 }
 
 static int ehea_start_xmit(struct sk_buff *skb, struct net_device *dev)
@@ -2055,9 +2053,9 @@
 	memset(swqe, 0, SWQE_HEADER_SIZE);
 	atomic_dec(&pr->swqe_avail);
 
-	if (skb_vlan_tag_present(skb)) {
+	if (vlan_tx_tag_present(skb)) {
 		swqe->tx_control |= EHEA_SWQE_VLAN_INSERT;
-		swqe->vlan_tag = skb_vlan_tag_get(skb);
+		swqe->vlan_tag = vlan_tx_tag_get(skb);
 	}
 
 	pr->tx_packets++;
@@ -2438,8 +2436,6 @@
 
 	netif_info(port, ifup, dev, "enabling port\n");
 
-	netif_carrier_off(dev);
-
 	ret = ehea_up(dev);
 	if (!ret) {
 		port_napi_enable(port);
@@ -2962,6 +2958,7 @@
 	.ndo_set_mac_address	= ehea_set_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_rx_mode	= ehea_set_multicast_list,
+	.ndo_change_mtu		= ehea_change_mtu,
 	.ndo_vlan_rx_add_vid	= ehea_vlan_rx_add_vid,
 	.ndo_vlan_rx_kill_vid	= ehea_vlan_rx_kill_vid,
 	.ndo_tx_timeout		= ehea_tx_watchdog,
@@ -3026,7 +3023,7 @@
 
 	dev->hw_features = NETIF_F_SG | NETIF_F_TSO |
 		      NETIF_F_IP_CSUM | NETIF_F_HW_VLAN_CTAG_TX;
-	dev->features = NETIF_F_SG | NETIF_F_TSO |
+	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_TSO |
 		      NETIF_F_HIGHDMA | NETIF_F_IP_CSUM |
 		      NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |
 		      NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_RXCSUM;
@@ -3034,16 +3031,13 @@
 			NETIF_F_IP_CSUM;
 	dev->watchdog_timeo = EHEA_WATCH_DOG_TIMEOUT;
 
-	/* MTU range: 68 - 9022 */
-	dev->min_mtu = ETH_MIN_MTU;
-	dev->max_mtu = EHEA_MAX_PACKET_SIZE;
-
 	INIT_WORK(&port->reset_task, ehea_reset_port);
 	INIT_DELAYED_WORK(&port->stats_work, ehea_update_stats);
 
 	init_waitqueue_head(&port->swqe_avail_wq);
 	init_waitqueue_head(&port->restart_wq);
 
+	memset(&port->stats, 0, sizeof(struct net_device_stats));
 	ret = register_netdev(dev);
 	if (ret) {
 		pr_err("register_netdev failed. ret=%d\n", ret);
@@ -3257,158 +3251,20 @@
 	device_remove_file(&dev->dev, &dev_attr_remove_port);
 }
 
-static int ehea_reboot_notifier(struct notifier_block *nb,
-				unsigned long action, void *unused)
-{
-	if (action == SYS_RESTART) {
-		pr_info("Reboot: freeing all eHEA resources\n");
-		ibmebus_unregister_driver(&ehea_driver);
-	}
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block ehea_reboot_nb = {
-	.notifier_call = ehea_reboot_notifier,
-};
-
-static int ehea_mem_notifier(struct notifier_block *nb,
-			     unsigned long action, void *data)
-{
-	int ret = NOTIFY_BAD;
-	struct memory_notify *arg = data;
-
-	mutex_lock(&dlpar_mem_lock);
-
-	switch (action) {
-	case MEM_CANCEL_OFFLINE:
-		pr_info("memory offlining canceled");
-		/* Fall through: re-add canceled memory block */
-
-	case MEM_ONLINE:
-		pr_info("memory is going online");
-		set_bit(__EHEA_STOP_XFER, &ehea_driver_flags);
-		if (ehea_add_sect_bmap(arg->start_pfn, arg->nr_pages))
-			goto out_unlock;
-		ehea_rereg_mrs();
-		break;
-
-	case MEM_GOING_OFFLINE:
-		pr_info("memory is going offline");
-		set_bit(__EHEA_STOP_XFER, &ehea_driver_flags);
-		if (ehea_rem_sect_bmap(arg->start_pfn, arg->nr_pages))
-			goto out_unlock;
-		ehea_rereg_mrs();
-		break;
-
-	default:
-		break;
-	}
-
-	ehea_update_firmware_handles();
-	ret = NOTIFY_OK;
-
-out_unlock:
-	mutex_unlock(&dlpar_mem_lock);
-	return ret;
-}
-
-static struct notifier_block ehea_mem_nb = {
-	.notifier_call = ehea_mem_notifier,
-};
-
-static void ehea_crash_handler(void)
-{
-	int i;
-
-	if (ehea_fw_handles.arr)
-		for (i = 0; i < ehea_fw_handles.num_entries; i++)
-			ehea_h_free_resource(ehea_fw_handles.arr[i].adh,
-					     ehea_fw_handles.arr[i].fwh,
-					     FORCE_FREE);
-
-	if (ehea_bcmc_regs.arr)
-		for (i = 0; i < ehea_bcmc_regs.num_entries; i++)
-			ehea_h_reg_dereg_bcmc(ehea_bcmc_regs.arr[i].adh,
-					      ehea_bcmc_regs.arr[i].port_id,
-					      ehea_bcmc_regs.arr[i].reg_type,
-					      ehea_bcmc_regs.arr[i].macaddr,
-					      0, H_DEREG_BCMC);
-}
-
-static atomic_t ehea_memory_hooks_registered;
-
-/* Register memory hooks on probe of first adapter */
-static int ehea_register_memory_hooks(void)
-{
-	int ret = 0;
-
-	if (atomic_inc_return(&ehea_memory_hooks_registered) > 1)
-		return 0;
-
-	ret = ehea_create_busmap();
-	if (ret) {
-		pr_info("ehea_create_busmap failed\n");
-		goto out;
-	}
-
-	ret = register_reboot_notifier(&ehea_reboot_nb);
-	if (ret) {
-		pr_info("register_reboot_notifier failed\n");
-		goto out;
-	}
-
-	ret = register_memory_notifier(&ehea_mem_nb);
-	if (ret) {
-		pr_info("register_memory_notifier failed\n");
-		goto out2;
-	}
-
-	ret = crash_shutdown_register(ehea_crash_handler);
-	if (ret) {
-		pr_info("crash_shutdown_register failed\n");
-		goto out3;
-	}
-
-	return 0;
-
-out3:
-	unregister_memory_notifier(&ehea_mem_nb);
-out2:
-	unregister_reboot_notifier(&ehea_reboot_nb);
-out:
-	atomic_dec(&ehea_memory_hooks_registered);
-	return ret;
-}
-
-static void ehea_unregister_memory_hooks(void)
-{
-	/* Only remove the hooks if we've registered them */
-	if (atomic_read(&ehea_memory_hooks_registered) == 0)
-		return;
-
-	unregister_reboot_notifier(&ehea_reboot_nb);
-	if (crash_shutdown_unregister(ehea_crash_handler))
-		pr_info("failed unregistering crash handler\n");
-	unregister_memory_notifier(&ehea_mem_nb);
-}
-
-static int ehea_probe_adapter(struct platform_device *dev)
+static int ehea_probe_adapter(struct platform_device *dev,
+			      const struct of_device_id *id)
 {
 	struct ehea_adapter *adapter;
 	const u64 *adapter_handle;
 	int ret;
 	int i;
 
-	ret = ehea_register_memory_hooks();
-	if (ret)
-		return ret;
-
 	if (!dev || !dev->dev.of_node) {
 		pr_err("Invalid ibmebus device probed\n");
 		return -EINVAL;
 	}
 
-	adapter = devm_kzalloc(&dev->dev, sizeof(*adapter), GFP_KERNEL);
+	adapter = kzalloc(sizeof(*adapter), GFP_KERNEL);
 	if (!adapter) {
 		ret = -ENOMEM;
 		dev_err(&dev->dev, "no mem for ehea_adapter\n");
@@ -3433,7 +3289,7 @@
 
 	adapter->pd = EHEA_PD_ID;
 
-	platform_set_drvdata(dev, adapter);
+	dev_set_drvdata(&dev->dev, adapter);
 
 
 	/* initialize adapter and ports */
@@ -3466,7 +3322,7 @@
 	}
 
 	ret = ibmebus_request_irq(adapter->neq->attr.ist1,
-				  ehea_interrupt_neq, 0,
+				  ehea_interrupt_neq, IRQF_DISABLED,
 				  "ehea_neq", adapter);
 	if (ret) {
 		dev_err(&dev->dev, "requesting NEQ IRQ failed\n");
@@ -3494,6 +3350,7 @@
 
 out_free_ad:
 	list_del(&adapter->list);
+	kfree(adapter);
 
 out:
 	ehea_update_firmware_handles();
@@ -3503,7 +3360,7 @@
 
 static int ehea_remove(struct platform_device *dev)
 {
-	struct ehea_adapter *adapter = platform_get_drvdata(dev);
+	struct ehea_adapter *adapter = dev_get_drvdata(&dev->dev);
 	int i;
 
 	for (i = 0; i < EHEA_MAX_PORTS; i++)
@@ -3520,12 +3377,88 @@
 	ehea_destroy_eq(adapter->neq);
 	ehea_remove_adapter_mr(adapter);
 	list_del(&adapter->list);
+	kfree(adapter);
 
 	ehea_update_firmware_handles();
 
 	return 0;
 }
 
+static void ehea_crash_handler(void)
+{
+	int i;
+
+	if (ehea_fw_handles.arr)
+		for (i = 0; i < ehea_fw_handles.num_entries; i++)
+			ehea_h_free_resource(ehea_fw_handles.arr[i].adh,
+					     ehea_fw_handles.arr[i].fwh,
+					     FORCE_FREE);
+
+	if (ehea_bcmc_regs.arr)
+		for (i = 0; i < ehea_bcmc_regs.num_entries; i++)
+			ehea_h_reg_dereg_bcmc(ehea_bcmc_regs.arr[i].adh,
+					      ehea_bcmc_regs.arr[i].port_id,
+					      ehea_bcmc_regs.arr[i].reg_type,
+					      ehea_bcmc_regs.arr[i].macaddr,
+					      0, H_DEREG_BCMC);
+}
+
+static int ehea_mem_notifier(struct notifier_block *nb,
+                             unsigned long action, void *data)
+{
+	int ret = NOTIFY_BAD;
+	struct memory_notify *arg = data;
+
+	mutex_lock(&dlpar_mem_lock);
+
+	switch (action) {
+	case MEM_CANCEL_OFFLINE:
+		pr_info("memory offlining canceled");
+		/* Readd canceled memory block */
+	case MEM_ONLINE:
+		pr_info("memory is going online");
+		set_bit(__EHEA_STOP_XFER, &ehea_driver_flags);
+		if (ehea_add_sect_bmap(arg->start_pfn, arg->nr_pages))
+			goto out_unlock;
+		ehea_rereg_mrs();
+		break;
+	case MEM_GOING_OFFLINE:
+		pr_info("memory is going offline");
+		set_bit(__EHEA_STOP_XFER, &ehea_driver_flags);
+		if (ehea_rem_sect_bmap(arg->start_pfn, arg->nr_pages))
+			goto out_unlock;
+		ehea_rereg_mrs();
+		break;
+	default:
+		break;
+	}
+
+	ehea_update_firmware_handles();
+	ret = NOTIFY_OK;
+
+out_unlock:
+	mutex_unlock(&dlpar_mem_lock);
+	return ret;
+}
+
+static struct notifier_block ehea_mem_nb = {
+	.notifier_call = ehea_mem_notifier,
+};
+
+static int ehea_reboot_notifier(struct notifier_block *nb,
+				unsigned long action, void *unused)
+{
+	if (action == SYS_RESTART) {
+		pr_info("Reboot: freeing all eHEA resources\n");
+		ibmebus_unregister_driver(&ehea_driver);
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ehea_reboot_nb = {
+	.notifier_call = ehea_reboot_notifier,
+};
+
 static int check_module_parm(void)
 {
 	int ret = 0;
@@ -3579,10 +3512,26 @@
 	if (ret)
 		goto out;
 
+	ret = ehea_create_busmap();
+	if (ret)
+		goto out;
+
+	ret = register_reboot_notifier(&ehea_reboot_nb);
+	if (ret)
+		pr_info("failed registering reboot notifier\n");
+
+	ret = register_memory_notifier(&ehea_mem_nb);
+	if (ret)
+		pr_info("failed registering memory remove notifier\n");
+
+	ret = crash_shutdown_register(ehea_crash_handler);
+	if (ret)
+		pr_info("failed registering crash handler\n");
+
 	ret = ibmebus_register_driver(&ehea_driver);
 	if (ret) {
 		pr_err("failed registering eHEA device driver on ebus\n");
-		goto out;
+		goto out2;
 	}
 
 	ret = driver_create_file(&ehea_driver.driver,
@@ -3590,22 +3539,32 @@
 	if (ret) {
 		pr_err("failed to register capabilities attribute, ret=%d\n",
 		       ret);
-		goto out2;
+		goto out3;
 	}
 
 	return ret;
 
-out2:
+out3:
 	ibmebus_unregister_driver(&ehea_driver);
+out2:
+	unregister_memory_notifier(&ehea_mem_nb);
+	unregister_reboot_notifier(&ehea_reboot_nb);
+	crash_shutdown_unregister(ehea_crash_handler);
 out:
 	return ret;
 }
 
 static void __exit ehea_module_exit(void)
 {
+	int ret;
+
 	driver_remove_file(&ehea_driver.driver, &driver_attr_capabilities);
 	ibmebus_unregister_driver(&ehea_driver);
-	ehea_unregister_memory_hooks();
+	unregister_reboot_notifier(&ehea_reboot_nb);
+	ret = crash_shutdown_unregister(ehea_crash_handler);
+	if (ret)
+		pr_info("failed unregistering crash handler\n");
+	unregister_memory_notifier(&ehea_mem_nb);
 	kfree(ehea_fw_handles.arr);
 	kfree(ehea_bcmc_regs.arr);
 	ehea_destroy_busmap();
diff --git a/drivers/net/ethernet/ibm/ehea/ehea_qmr.c b/drivers/net/ethernet/ibm/ehea/ehea_qmr.c
--- a/drivers/net/ethernet/ibm/ehea/ehea_qmr.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/ehea/ehea_qmr.c	2015-09-24 17:47:25.000000000 +0200
@@ -103,14 +103,12 @@
 
 static void hw_queue_dtor(struct hw_queue *queue)
 {
-	int pages_per_kpage;
+	int pages_per_kpage = PAGE_SIZE / queue->pagesize;
 	int i, nr_pages;
 
 	if (!queue || !queue->queue_pages)
 		return;
 
-	pages_per_kpage = PAGE_SIZE / queue->pagesize;
-
 	nr_pages = queue->queue_length / queue->pagesize;
 
 	for (i = 0; i < nr_pages; i += pages_per_kpage)
diff --git a/drivers/net/ethernet/ibm/ehea/Makefile b/drivers/net/ethernet/ibm/ehea/Makefile
--- a/drivers/net/ethernet/ibm/ehea/Makefile	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/ehea/Makefile	2015-09-24 17:47:25.000000000 +0200
@@ -1,6 +1,6 @@
 #
 # Makefile for the eHEA ethernet device driver for IBM eServer System p
 #
-ehea-y = ehea_main.o ehea_phyp.o ehea_qmr.o ehea_ethtool.o
+ehea-y = ehea_main.o ehea_phyp.o ehea_qmr.o ehea_ethtool.o ehea_phyp.o
 obj-$(CONFIG_EHEA) += ehea.o
 
diff --git a/drivers/net/ethernet/ibm/emac/core.c b/drivers/net/ethernet/ibm/emac/core.c
--- a/drivers/net/ethernet/ibm/emac/core.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/core.c	2017-06-13 00:00:10.000000000 +0200
@@ -79,6 +77,13 @@
     ("Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>");
 MODULE_LICENSE("GPL");
 
+/*
+ * PPC64 doesn't (yet) have a cacheable_memcpy
+ */
+#ifdef CONFIG_PPC64
+#define cacheable_memcpy(d,s,n) memcpy((d),(s),(n))
+#endif
+
 /* minimum number of free TX descriptors required to wake up TX process */
 #define EMAC_TX_WAKEUP_THRESH		(NUM_TX_BUFF / 4)
 
@@ -190,7 +195,7 @@
 	"tx_bd_excessive_collisions", "tx_bd_late_collision",
 	"tx_bd_multple_collisions", "tx_bd_single_collision",
 	"tx_bd_underrun", "tx_bd_sqe", "tx_parity", "tx_underrun", "tx_sqe",
-	"tx_errors"
+	"tx_errors", "rx_bd_mal_skipped", "rx_bd_mal_reordered"
 };
 
 static irqreturn_t emac_irq(int irq, void *dev_instance);
@@ -498,6 +503,9 @@
 	case 16384:
 		ret |= EMAC4_MR1_TFS_16K;
 		break;
+	case 8192:
+		ret |= EMAC4_MR1_TFS_8K;
+		break;
 	case 4096:
 		ret |= EMAC4_MR1_TFS_4K;
 		break;
@@ -513,6 +521,9 @@
 	case 16384:
 		ret |= EMAC4_MR1_RFS_16K;
 		break;
+	case 8192:
+		ret |= EMAC4_MR1_RFS_8K;
+		break;
 	case 4096:
 		ret |= EMAC4_MR1_RFS_4K;
 		break;
@@ -977,10 +988,7 @@
 		dev->mcast_pending = 1;
 		return;
 	}
-
-	mutex_lock(&dev->link_lock);
 	__emac_set_multicast_list(dev);
-	mutex_unlock(&dev->link_lock);
 }
 
 static int emac_set_mac_address(struct net_device *ndev, void *sa)
@@ -1099,6 +1107,9 @@
 	struct emac_instance *dev = netdev_priv(ndev);
 	int ret = 0;
 
+	if (new_mtu < EMAC_MIN_MTU || new_mtu > dev->max_mtu)
+		return -EINVAL;
+
 	DBG(dev, "change_mtu(%d)" NL, new_mtu);
 
 	if (netif_running(ndev)) {
@@ -1693,7 +1704,7 @@
 			dev_kfree_skb(dev->rx_sg_skb);
 			dev->rx_sg_skb = NULL;
 		} else {
-			memcpy(skb_tail_pointer(dev->rx_sg_skb),
+			memcpy(skb_tail_pointer(dev->rx_sg_skb),
 					 dev->rx_skb[slot]->data, len);
 			skb_put(dev->rx_sg_skb, len);
 			emac_recycle_rx_skb(dev, slot, len);
@@ -1709,6 +1720,7 @@
 {
 	struct emac_instance *dev = param;
 	int slot = dev->rx_slot, received = 0;
+	int nextslot;
 
 	DBG2(dev, "poll_rx(%d)" NL, budget);
 
@@ -1716,10 +1728,33 @@
 	while (budget > 0) {
 		int len;
 		struct sk_buff *skb;
+		u16 nextctrl;
 		u16 ctrl = dev->rx_desc[slot].ctrl;
 
-		if (ctrl & MAL_RX_CTRL_EMPTY)
-			break;
+		if (ctrl & MAL_RX_CTRL_EMPTY) {
+			nextslot = (slot + 1) % NUM_RX_BUFF;
+			nextctrl = dev->rx_desc[nextslot].ctrl;
+			if (nextctrl & MAL_RX_CTRL_EMPTY)
+				break;
+
+			/*
+			 * we see MAL update of the next BD.
+			 * do sync and check current BD again
+			 */
+			mb();
+			ctrl = dev->rx_desc[slot].ctrl;
+			if (ctrl & MAL_RX_CTRL_EMPTY) {
+				/*
+				 * current BD ctrl is empty even after sync
+				 * jump to the next one
+				 */
+				++dev->estats.rx_bd_mal_skipped;
+				slot = nextslot;
+				ctrl = nextctrl;
+			} else {
+				++dev->estats.rx_bd_mal_reordered;
+			}
+		}
 
 		skb = dev->rx_skb[slot];
 		mb();
@@ -1750,7 +1785,8 @@
 				goto oom;
 
 			skb_reserve(copy_skb, EMAC_RX_SKB_HEADROOM + 2);
-			memcpy(copy_skb->data - 2, skb->data - 2, len + 2);
+			memcpy(copy_skb->data - 2, skb->data - 2,
+					 len + 2);
 			emac_recycle_rx_skb(dev, slot, len);
 			skb = copy_skb;
 		} else if (unlikely(emac_alloc_rx_skb(dev, slot, GFP_ATOMIC)))
@@ -2111,8 +2147,12 @@
 
 static int emac_get_regs_len(struct emac_instance *dev)
 {
+	if (emac_has_feature(dev, EMAC_FTR_EMAC4))
 		return sizeof(struct emac_ethtool_regs_subhdr) +
-			sizeof(struct emac_regs);
+			EMAC4_ETHTOOL_REGS_SIZE(dev);
+	else
+		return sizeof(struct emac_ethtool_regs_subhdr) +
+			EMAC_ETHTOOL_REGS_SIZE(dev);
 }
 
 static int emac_ethtool_get_regs_len(struct net_device *ndev)
@@ -2137,15 +2177,15 @@
 	struct emac_ethtool_regs_subhdr *hdr = buf;
 
 	hdr->index = dev->cell_index;
-	if (emac_has_feature(dev, EMAC_FTR_EMAC4SYNC)) {
-		hdr->version = EMAC4SYNC_ETHTOOL_REGS_VER;
-	} else if (emac_has_feature(dev, EMAC_FTR_EMAC4)) {
+	if (emac_has_feature(dev, EMAC_FTR_EMAC4)) {
 		hdr->version = EMAC4_ETHTOOL_REGS_VER;
+		memcpy_fromio(hdr + 1, dev->emacp, EMAC4_ETHTOOL_REGS_SIZE(dev));
+		return (void *)(hdr + 1) + EMAC4_ETHTOOL_REGS_SIZE(dev);
 	} else {
 		hdr->version = EMAC_ETHTOOL_REGS_VER;
+		memcpy_fromio(hdr + 1, dev->emacp, EMAC_ETHTOOL_REGS_SIZE(dev));
+		return (void *)(hdr + 1) + EMAC_ETHTOOL_REGS_SIZE(dev);
 	}
-	memcpy_fromio(hdr + 1, dev->emacp, sizeof(struct emac_regs));
-	return (void *)(hdr + 1) + sizeof(struct emac_regs);
 }
 
 static void emac_ethtool_get_regs(struct net_device *ndev,
@@ -2231,6 +2271,7 @@
 	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 	snprintf(info->bus_info, sizeof(info->bus_info), "PPC 4xx EMAC-%d %s",
 		 dev->cell_index, dev->ofdev->dev.of_node->full_name);
+	info->regdump_len = emac_ethtool_get_regs_len(ndev);
 }
 
 static const struct ethtool_ops emac_ethtool_ops = {
@@ -2328,7 +2369,7 @@
 		if (deps[i].ofdev == NULL)
 			continue;
 		if (deps[i].drvdata == NULL)
-			deps[i].drvdata = platform_get_drvdata(deps[i].ofdev);
+			deps[i].drvdata = dev_get_drvdata(&deps[i].ofdev->dev);
 		if (deps[i].drvdata != NULL)
 			there++;
 	}
@@ -2337,11 +2378,16 @@
 
 static void emac_put_deps(struct emac_instance *dev)
 {
-	of_dev_put(dev->mal_dev);
-	of_dev_put(dev->zmii_dev);
-	of_dev_put(dev->rgmii_dev);
-	of_dev_put(dev->mdio_dev);
-	of_dev_put(dev->tah_dev);
+	if (dev->mal_dev)
+		of_dev_put(dev->mal_dev);
+	if (dev->zmii_dev)
+		of_dev_put(dev->zmii_dev);
+	if (dev->rgmii_dev)
+		of_dev_put(dev->rgmii_dev);
+	if (dev->mdio_dev)
+		of_dev_put(dev->mdio_dev);
+	if (dev->tah_dev)
+		of_dev_put(dev->tah_dev);
 }
 
 static int emac_of_bus_notify(struct notifier_block *nb, unsigned long action,
@@ -2380,8 +2426,9 @@
 	bus_unregister_notifier(&platform_bus_type, &emac_of_bus_notifier);
 	err = emac_check_deps(dev, deps) ? 0 : -ENODEV;
 	for (i = 0; i < EMAC_DEP_COUNT; i++) {
-		of_node_put(deps[i].node);
-		if (err)
+		if (deps[i].node)
+			of_node_put(deps[i].node);
+		if (err && deps[i].ofdev)
 			of_dev_put(deps[i].ofdev);
 	}
 	if (err == 0) {
@@ -2391,7 +2438,8 @@
 		dev->tah_dev = deps[EMAC_DEP_TAH_IDX].ofdev;
 		dev->mdio_dev = deps[EMAC_DEP_MDIO_IDX].ofdev;
 	}
-	of_dev_put(deps[EMAC_DEP_PREV_IDX].ofdev);
+	if (deps[EMAC_DEP_PREV_IDX].ofdev)
+		of_dev_put(deps[EMAC_DEP_PREV_IDX].ofdev);
 	return err;
 }
 
@@ -2561,7 +2609,7 @@
 	if (emac_read_uint_prop(np, "cell-index", &dev->cell_index, 1))
 		return -ENXIO;
 	if (emac_read_uint_prop(np, "max-frame-size", &dev->max_mtu, 0))
-		dev->max_mtu = ETH_DATA_LEN;
+		dev->max_mtu = 1500;
 	if (emac_read_uint_prop(np, "rx-fifo-size", &dev->rx_fifo_size, 0))
 		dev->rx_fifo_size = 2048;
 	if (emac_read_uint_prop(np, "tx-fifo-size", &dev->tx_fifo_size, 0))
@@ -2685,7 +2733,7 @@
 		       np->full_name);
 		return -ENXIO;
 	}
-	memcpy(dev->ndev->dev_addr, p, ETH_ALEN);
+	memcpy(dev->ndev->dev_addr, p, 6);
 
 	/* IAHT and GAHT filter parameterization */
 	if (emac_has_feature(dev, EMAC_FTR_EMAC4SYNC)) {
@@ -2715,6 +2763,7 @@
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_mac_address	= emac_set_mac_address,
 	.ndo_start_xmit		= emac_start_xmit,
+	.ndo_change_mtu		= eth_change_mtu,
 };
 
 static const struct net_device_ops emac_gige_netdev_ops = {
@@ -2776,7 +2825,7 @@
 	/* Get interrupts. EMAC irq is mandatory, WOL irq is optional */
 	dev->emac_irq = irq_of_parse_and_map(np, 0);
 	dev->wol_irq = irq_of_parse_and_map(np, 1);
-	if (!dev->emac_irq) {
+	if (dev->emac_irq == NO_IRQ) {
 		printk(KERN_ERR "%s: Can't map main interrupt\n", np->full_name);
 		goto err_free;
 	}
@@ -2807,9 +2856,9 @@
 		/*  display more info about what's missing ? */
 		goto err_reg_unmap;
 	}
-	dev->mal = platform_get_drvdata(dev->mal_dev);
+	dev->mal = dev_get_drvdata(&dev->mal_dev->dev);
 	if (dev->mdio_dev != NULL)
-		dev->mdio_instance = platform_get_drvdata(dev->mdio_dev);
+		dev->mdio_instance = dev_get_drvdata(&dev->mdio_dev->dev);
 
 	/* Register with MAL */
 	dev->commac.ops = &emac_commac_ops;
@@ -2904,7 +2949,7 @@
 	 * fully initialized
 	 */
 	wmb();
-	platform_set_drvdata(ofdev, dev);
+	dev_set_drvdata(&ofdev->dev, dev);
 
 	/* There's a new kid in town ! Let's tell everybody */
 	wake_up_all(&emac_probe_wait);
@@ -2943,9 +2988,9 @@
  err_reg_unmap:
 	iounmap(dev->emacp);
  err_irq_unmap:
-	if (dev->wol_irq)
+	if (dev->wol_irq != NO_IRQ)
 		irq_dispose_mapping(dev->wol_irq);
-	if (dev->emac_irq)
+	if (dev->emac_irq != NO_IRQ)
 		irq_dispose_mapping(dev->emac_irq);
  err_free:
 	free_netdev(ndev);
@@ -2963,10 +3008,12 @@
 
 static int emac_remove(struct platform_device *ofdev)
 {
-	struct emac_instance *dev = platform_get_drvdata(ofdev);
+	struct emac_instance *dev = dev_get_drvdata(&ofdev->dev);
 
 	DBG(dev, "remove" NL);
 
+	dev_set_drvdata(&ofdev->dev, NULL);
+
 	unregister_netdev(dev->ndev);
 
 	cancel_work_sync(&dev->reset_work);
@@ -2987,9 +3034,9 @@
 	emac_dbg_unregister(dev);
 	iounmap(dev->emacp);
 
-	if (dev->wol_irq)
+	if (dev->wol_irq != NO_IRQ)
 		irq_dispose_mapping(dev->wol_irq);
-	if (dev->emac_irq)
+	if (dev->emac_irq != NO_IRQ)
 		irq_dispose_mapping(dev->emac_irq);
 
 	free_netdev(dev->ndev);
@@ -2998,7 +3045,7 @@
 }
 
 /* XXX Features in here should be replaced by properties... */
-static const struct of_device_id emac_match[] =
+static struct of_device_id emac_match[] =
 {
 	{
 		.type		= "network",
@@ -3019,6 +3066,7 @@
 static struct platform_driver emac_driver = {
 	.driver = {
 		.name = "emac",
+		.owner = THIS_MODULE,
 		.of_match_table = emac_match,
 	},
 	.probe = emac_probe,
@@ -3028,7 +3076,7 @@
 static void __init emac_make_bootlist(void)
 {
 	struct device_node *np = NULL;
-	int j, max, i = 0;
+	int j, max, i = 0, k;
 	int cell_indices[EMAC_BOOT_LIST_SIZE];
 
 	/* Collect EMACs */
@@ -3055,12 +3103,26 @@
 	for (i = 0; max > 1 && (i < (max - 1)); i++)
 		for (j = i; j < max; j++) {
 			if (cell_indices[i] > cell_indices[j]) {
-				swap(emac_boot_list[i], emac_boot_list[j]);
-				swap(cell_indices[i], cell_indices[j]);
+				np = emac_boot_list[i];
+				emac_boot_list[i] = emac_boot_list[j];
+				emac_boot_list[j] = np;
+				k = cell_indices[i];
+				cell_indices[i] = cell_indices[j];
+				cell_indices[j] = k;
 			}
 		}
 }
 
+static void __exit emac_destroy_bootlist(void)
+{
+	int i;
+	/* Destroy EMAC boot list */
+	for (i = 0; i < EMAC_BOOT_LIST_SIZE; i++)
+		if (emac_boot_list[i])
+			of_node_put(emac_boot_list[i]);
+
+}
+
 static int __init emac_init(void)
 {
 	int rc;
@@ -3101,6 +3163,8 @@
  err_mal:
 	mal_exit();
  err:
+	emac_destroy_bootlist();
+	emac_fini_debug();
 	return rc;
 }
 
@@ -3114,11 +3178,8 @@
 	rgmii_exit();
 	zmii_exit();
 	mal_exit();
+	emac_destroy_bootlist();
 	emac_fini_debug();
-
-	/* Destroy EMAC boot list */
-	for (i = 0; i < EMAC_BOOT_LIST_SIZE; i++)
-		of_node_put(emac_boot_list[i]);
 }
 
 module_init(emac_init);
diff --git a/drivers/net/ethernet/ibm/emac/core.h b/drivers/net/ethernet/ibm/emac/core.h
--- a/drivers/net/ethernet/ibm/emac/core.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/core.h	2017-06-13 00:00:10.000000000 +0200
@@ -26,6 +26,7 @@
 #define __IBM_NEWEMAC_CORE_H
 
 #include <linux/module.h>
+#include <linux/init.h>
 #include <linux/list.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -159,6 +160,10 @@
 	u64 tx_underrun;
 	u64 tx_sqe;
 	u64 tx_errors;
+
+	/* MAL BD write errors */
+	u64 rx_bd_mal_skipped;
+	u64 rx_bd_mal_reordered;
 };
 
 #define EMAC_ETHTOOL_STATS_COUNT	((sizeof(struct emac_stats) + \
@@ -181,7 +186,7 @@
 	struct mal_commac		commac;
 
 	/* PHY infos */
-	int				phy_mode;
+	u32				phy_mode;
 	u32				phy_map;
 	u32				phy_address;
 	u32				phy_feat_exc;
@@ -460,8 +465,11 @@
 	u32 index;
 };
 
-#define EMAC_ETHTOOL_REGS_VER		3
-#define EMAC4_ETHTOOL_REGS_VER		4
-#define EMAC4SYNC_ETHTOOL_REGS_VER	5
+#define EMAC_ETHTOOL_REGS_VER		0
+#define EMAC_ETHTOOL_REGS_SIZE(dev) 	((dev)->rsrc_regs.end - \
+					 (dev)->rsrc_regs.start + 1)
+#define EMAC4_ETHTOOL_REGS_VER      	1
+#define EMAC4_ETHTOOL_REGS_SIZE(dev)	((dev)->rsrc_regs.end -	\
+					 (dev)->rsrc_regs.start + 1)
 
 #endif /* __IBM_NEWEMAC_CORE_H */
diff --git a/drivers/net/ethernet/ibm/emac/debug.h b/drivers/net/ethernet/ibm/emac/debug.h
--- a/drivers/net/ethernet/ibm/emac/debug.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/debug.h	2015-09-24 17:47:25.000000000 +0200
@@ -29,13 +29,13 @@
 struct emac_instance;
 struct mal_instance;
 
-void emac_dbg_register(struct emac_instance *dev);
-void emac_dbg_unregister(struct emac_instance *dev);
-void mal_dbg_register(struct mal_instance *mal);
-void mal_dbg_unregister(struct mal_instance *mal);
-int emac_init_debug(void) __init;
-void emac_fini_debug(void) __exit;
-void emac_dbg_dump_all(void);
+extern void emac_dbg_register(struct emac_instance *dev);
+extern void emac_dbg_unregister(struct emac_instance *dev);
+extern void mal_dbg_register(struct mal_instance *mal);
+extern void mal_dbg_unregister(struct mal_instance *mal);
+extern int emac_init_debug(void) __init;
+extern void emac_fini_debug(void) __exit;
+extern void emac_dbg_dump_all(void);
 
 # define DBG_LEVEL		1
 
diff --git a/drivers/net/ethernet/ibm/emac/emac.h b/drivers/net/ethernet/ibm/emac/emac.h
--- a/drivers/net/ethernet/ibm/emac/emac.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/emac.h	2017-06-13 00:00:10.000000000 +0200
@@ -151,9 +151,11 @@
 
 #define EMAC4_MR1_RFS_2K		0x00100000
 #define EMAC4_MR1_RFS_4K		0x00180000
+#define EMAC4_MR1_RFS_8K		0x00200000
 #define EMAC4_MR1_RFS_16K		0x00280000
 #define EMAC4_MR1_TFS_2K       		0x00020000
 #define EMAC4_MR1_TFS_4K		0x00030000
+#define EMAC4_MR1_TFS_8K		0x00040000
 #define EMAC4_MR1_TFS_16K		0x00050000
 #define EMAC4_MR1_TR			0x00008000
 #define EMAC4_MR1_MWSW_001		0x00001000
@@ -242,7 +244,7 @@
 #define EMAC_STACR_PHYE			0x00004000
 #define EMAC_STACR_STAC_MASK		0x00003000
 #define EMAC_STACR_STAC_READ		0x00001000
-#define EMAC_STACR_STAC_WRITE		0x00002000
+#define EMAC_STACR_STAC_WRITE		0x00000800
 #define EMAC_STACR_OPBC_MASK		0x00000C00
 #define EMAC_STACR_OPBC_50		0x00000000
 #define EMAC_STACR_OPBC_66		0x00000400
diff --git a/drivers/net/ethernet/ibm/emac/mal.c b/drivers/net/ethernet/ibm/emac/mal.c
--- a/drivers/net/ethernet/ibm/emac/mal.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/mal.c	2017-06-13 00:00:10.000000000 +0200
@@ -264,9 +263,7 @@
 {
 	if (likely(napi_schedule_prep(&mal->napi))) {
 		MAL_DBG2(mal, "schedule_poll" NL);
-		spin_lock(&mal->lock);
 		mal_disable_eob_irq(mal);
-		spin_unlock(&mal->lock);
 		__napi_schedule(&mal->napi);
 	} else
 		MAL_DBG2(mal, "already in poll" NL);
@@ -445,13 +442,15 @@
 		if (unlikely(mc->ops->peek_rx(mc->dev) ||
 			     test_bit(MAL_COMMAC_RX_STOPPED, &mc->flags))) {
 			MAL_DBG2(mal, "rotting packet" NL);
-			if (!napi_reschedule(napi))
-				goto more_work;
+			if (napi_reschedule(napi))
+				mal_disable_eob_irq(mal);
+			else
+				MAL_DBG2(mal, "already in poll list" NL);
 
-			spin_lock_irqsave(&mal->lock, flags);
-			mal_disable_eob_irq(mal);
-			spin_unlock_irqrestore(&mal->lock, flags);
-			goto again;
+			if (budget > 0)
+				goto again;
+			else
+				goto more_work;
 		}
 		mc->ops->poll_tx(mc->dev);
 	}
@@ -597,8 +596,9 @@
 		mal->rxde_irq = irq_of_parse_and_map(ofdev->dev.of_node, 4);
 	}
 
-	if (!mal->txeob_irq || !mal->rxeob_irq || !mal->serr_irq ||
-	    !mal->txde_irq  || !mal->rxde_irq) {
+	if (mal->txeob_irq == NO_IRQ || mal->rxeob_irq == NO_IRQ ||
+	    mal->serr_irq == NO_IRQ || mal->txde_irq == NO_IRQ ||
+	    mal->rxde_irq == NO_IRQ) {
 		printk(KERN_ERR
 		       "mal%d: failed to map interrupts !\n", index);
 		err = -ENODEV;
@@ -637,8 +637,8 @@
 	bd_size = sizeof(struct mal_descriptor) *
 		(NUM_TX_BUFF * mal->num_tx_chans +
 		 NUM_RX_BUFF * mal->num_rx_chans);
-	mal->bd_virt = dma_zalloc_coherent(&ofdev->dev, bd_size, &mal->bd_dma,
-					   GFP_KERNEL);
+	mal->bd_virt = dma_alloc_coherent(&ofdev->dev, bd_size, &mal->bd_dma,
+					  GFP_KERNEL | __GFP_ZERO);
 	if (mal->bd_virt == NULL) {
 		err = -ENOMEM;
 		goto fail_unmap;
@@ -681,7 +681,10 @@
 		goto fail6;
 
 	/* Enable all MAL SERR interrupt sources */
-	set_mal_dcrn(mal, MAL_IER, MAL_IER_EVENTS);
+	if (mal->version == 2)
+		set_mal_dcrn(mal, MAL_IER, MAL2_IER_EVENTS);
+	else
+		set_mal_dcrn(mal, MAL_IER, MAL1_IER_EVENTS);
 
 	/* Enable EOB interrupt */
 	mal_enable_eob_irq(mal);
@@ -693,7 +696,7 @@
 
 	/* Advertise this instance to the rest of the world */
 	wmb();
-	platform_set_drvdata(ofdev, mal);
+	dev_set_drvdata(&ofdev->dev, mal);
 
 	mal_dbg_register(mal);
 
@@ -719,19 +722,18 @@
 
 static int mal_remove(struct platform_device *ofdev)
 {
-	struct mal_instance *mal = platform_get_drvdata(ofdev);
+	struct mal_instance *mal = dev_get_drvdata(&ofdev->dev);
 
 	MAL_DBG(mal, "remove" NL);
 
-	/* Synchronize with scheduled polling */
-	napi_disable(&mal->napi);
-
 	if (!list_empty(&mal->list))
 		/* This is *very* bad */
 		WARN(1, KERN_EMERG
 		       "mal%d: commac list is not empty on remove!\n",
 		       mal->index);
 
+	dev_set_drvdata(&ofdev->dev, NULL);
+
 	free_irq(mal->serr_irq, mal);
 	free_irq(mal->txde_irq, mal);
 	free_irq(mal->txeob_irq, mal);
@@ -752,7 +754,7 @@
 	return 0;
 }
 
-static const struct of_device_id mal_platform_match[] =
+static struct of_device_id mal_platform_match[] =
 {
 	{
 		.compatible	= "ibm,mcmal",
@@ -775,6 +777,7 @@
 static struct platform_driver mal_of_driver = {
 	.driver = {
 		.name = "mcmal",
+		.owner = THIS_MODULE,
 		.of_match_table = mal_platform_match,
 	},
 	.probe = mal_probe,
diff --git a/drivers/net/ethernet/ibm/emac/mal.h b/drivers/net/ethernet/ibm/emac/mal.h
--- a/drivers/net/ethernet/ibm/emac/mal.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/mal.h	2015-09-24 17:47:25.000000000 +0200
@@ -95,21 +95,25 @@
 
 
 #define MAL_IER			0x02
-/* MAL IER bits */
 #define   MAL_IER_DE		0x00000010
 #define   MAL_IER_OTE		0x00000004
 #define   MAL_IER_OE		0x00000002
 #define   MAL_IER_PE		0x00000001
+/* MAL V1 IER bits */
+#define   MAL1_IER_NWE		0x00000008
+#define   MAL1_IER_SOC_EVENTS	MAL1_IER_NWE
+#define   MAL1_IER_EVENTS	(MAL1_IER_SOC_EVENTS | MAL_IER_DE | \
+				 MAL_IER_OTE | MAL_IER_OE | MAL_IER_PE)
 
-/* PLB read/write/timeout errors */
-#define   MAL_IER_PTE		0x00000080
-#define   MAL_IER_PRE		0x00000040
-#define   MAL_IER_PWE		0x00000020
-
-#define   MAL_IER_SOC_EVENTS	(MAL_IER_PTE | MAL_IER_PRE | MAL_IER_PWE)
-#define   MAL_IER_EVENTS	(MAL_IER_SOC_EVENTS | MAL_IER_DE | \
+/* MAL V2 IER bits */
+#define   MAL2_IER_PT		0x00000080
+#define   MAL2_IER_PRE		0x00000040
+#define   MAL2_IER_PWE		0x00000020
+#define   MAL2_IER_SOC_EVENTS	(MAL2_IER_PT | MAL2_IER_PRE | MAL2_IER_PWE)
+#define   MAL2_IER_EVENTS	(MAL2_IER_SOC_EVENTS | MAL_IER_DE | \
 				 MAL_IER_OTE | MAL_IER_OE | MAL_IER_PE)
 
+
 #define MAL_TXCASR		0x04
 #define MAL_TXCARR		0x05
 #define MAL_TXEOBISR		0x06
diff --git a/drivers/net/ethernet/ibm/emac/phy.c b/drivers/net/ethernet/ibm/emac/phy.c
--- a/drivers/net/ethernet/ibm/emac/phy.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/phy.c	2015-09-24 17:47:25.000000000 +0200
@@ -470,38 +470,12 @@
 	.ops		= &m88e1112_phy_ops,
 };
 
-static int ar8035_init(struct mii_phy *phy)
-{
-	phy_write(phy, 0x1d, 0x5); /* Address debug register 5 */
-	phy_write(phy, 0x1e, 0x2d47); /* Value copied from u-boot */
-	phy_write(phy, 0x1d, 0xb);    /* Address hib ctrl */
-	phy_write(phy, 0x1e, 0xbc20); /* Value copied from u-boot */
-
-	return 0;
-}
-
-static struct mii_phy_ops ar8035_phy_ops = {
-	.init		= ar8035_init,
-	.setup_aneg	= genmii_setup_aneg,
-	.setup_forced	= genmii_setup_forced,
-	.poll_link	= genmii_poll_link,
-	.read_link	= genmii_read_link,
-};
-
-static struct mii_phy_def ar8035_phy_def = {
-	.phy_id		= 0x004dd070,
-	.phy_id_mask	= 0xfffffff0,
-	.name		= "Atheros 8035 Gigabit Ethernet",
-	.ops		= &ar8035_phy_ops,
-};
-
 static struct mii_phy_def *mii_phy_table[] = {
 	&et1011c_phy_def,
 	&cis8201_phy_def,
 	&bcm5248_phy_def,
 	&m88e1111_phy_def,
 	&m88e1112_phy_def,
-	&ar8035_phy_def,
 	&genmii_phy_def,
 	NULL
 };
diff --git a/drivers/net/ethernet/ibm/emac/rgmii.c b/drivers/net/ethernet/ibm/emac/rgmii.c
--- a/drivers/net/ethernet/ibm/emac/rgmii.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/rgmii.c	2017-06-13 00:00:10.000000000 +0200
@@ -97,7 +96,7 @@
 
 int rgmii_attach(struct platform_device *ofdev, int input, int mode)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct rgmii_regs __iomem *p = dev->base;
 
 	RGMII_DBG(dev, "attach(%d)" NL, input);
@@ -126,7 +125,7 @@
 
 void rgmii_set_speed(struct platform_device *ofdev, int input, int speed)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct rgmii_regs __iomem *p = dev->base;
 	u32 ssr;
 
@@ -150,7 +149,7 @@
 
 void rgmii_get_mdio(struct platform_device *ofdev, int input)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct rgmii_regs __iomem *p = dev->base;
 	u32 fer;
 
@@ -171,7 +170,7 @@
 
 void rgmii_put_mdio(struct platform_device *ofdev, int input)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct rgmii_regs __iomem *p = dev->base;
 	u32 fer;
 
@@ -192,7 +191,7 @@
 
 void rgmii_detach(struct platform_device *ofdev, int input)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct rgmii_regs __iomem *p;
 
 	BUG_ON(!dev || dev->users == 0);
@@ -218,7 +217,7 @@
 
 void *rgmii_dump_regs(struct platform_device *ofdev, void *buf)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct emac_ethtool_regs_subhdr *hdr = buf;
 	struct rgmii_regs *regs = (struct rgmii_regs *)(hdr + 1);
 
@@ -283,7 +282,7 @@
 	       (dev->flags & EMAC_RGMII_FLAG_HAS_MDIO) ? "" : "out");
 
 	wmb();
-	platform_set_drvdata(ofdev, dev);
+	dev_set_drvdata(&ofdev->dev, dev);
 
 	return 0;
 
@@ -295,7 +294,9 @@
 
 static int rgmii_remove(struct platform_device *ofdev)
 {
-	struct rgmii_instance *dev = platform_get_drvdata(ofdev);
+	struct rgmii_instance *dev = dev_get_drvdata(&ofdev->dev);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
 
 	WARN_ON(dev->users != 0);
 
@@ -305,7 +306,7 @@
 	return 0;
 }
 
-static const struct of_device_id rgmii_match[] =
+static struct of_device_id rgmii_match[] =
 {
 	{
 		.compatible	= "ibm,rgmii",
@@ -319,6 +320,7 @@
 static struct platform_driver rgmii_driver = {
 	.driver = {
 		.name = "emac-rgmii",
+		.owner = THIS_MODULE,
 		.of_match_table = rgmii_match,
 	},
 	.probe = rgmii_probe,
diff --git a/drivers/net/ethernet/ibm/emac/rgmii.h b/drivers/net/ethernet/ibm/emac/rgmii.h
--- a/drivers/net/ethernet/ibm/emac/rgmii.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/rgmii.h	2015-09-24 17:47:25.000000000 +0200
@@ -56,15 +56,15 @@
 
 #ifdef CONFIG_IBM_EMAC_RGMII
 
-int rgmii_init(void);
-void rgmii_exit(void);
-int rgmii_attach(struct platform_device *ofdev, int input, int mode);
-void rgmii_detach(struct platform_device *ofdev, int input);
-void rgmii_get_mdio(struct platform_device *ofdev, int input);
-void rgmii_put_mdio(struct platform_device *ofdev, int input);
-void rgmii_set_speed(struct platform_device *ofdev, int input, int speed);
-int rgmii_get_regs_len(struct platform_device *ofdev);
-void *rgmii_dump_regs(struct platform_device *ofdev, void *buf);
+extern int rgmii_init(void);
+extern void rgmii_exit(void);
+extern int rgmii_attach(struct platform_device *ofdev, int input, int mode);
+extern void rgmii_detach(struct platform_device *ofdev, int input);
+extern void rgmii_get_mdio(struct platform_device *ofdev, int input);
+extern void rgmii_put_mdio(struct platform_device *ofdev, int input);
+extern void rgmii_set_speed(struct platform_device *ofdev, int input, int speed);
+extern int rgmii_get_regs_len(struct platform_device *ofdev);
+extern void *rgmii_dump_regs(struct platform_device *ofdev, void *buf);
 
 #else
 
diff --git a/drivers/net/ethernet/ibm/emac/tah.c b/drivers/net/ethernet/ibm/emac/tah.c
--- a/drivers/net/ethernet/ibm/emac/tah.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/tah.c	2015-09-24 17:47:25.000000000 +0200
@@ -18,7 +18,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#include <linux/of_address.h>
 #include <asm/io.h>
 
 #include "emac.h"
@@ -26,7 +25,7 @@
 
 int tah_attach(struct platform_device *ofdev, int channel)
 {
-	struct tah_instance *dev = platform_get_drvdata(ofdev);
+	struct tah_instance *dev = dev_get_drvdata(&ofdev->dev);
 
 	mutex_lock(&dev->lock);
 	/* Reset has been done at probe() time... nothing else to do for now */
@@ -38,7 +37,7 @@
 
 void tah_detach(struct platform_device *ofdev, int channel)
 {
-	struct tah_instance *dev = platform_get_drvdata(ofdev);
+	struct tah_instance *dev = dev_get_drvdata(&ofdev->dev);
 
 	mutex_lock(&dev->lock);
 	--dev->users;
@@ -47,7 +46,7 @@
 
 void tah_reset(struct platform_device *ofdev)
 {
-	struct tah_instance *dev = platform_get_drvdata(ofdev);
+	struct tah_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct tah_regs __iomem *p = dev->base;
 	int n;
 
@@ -75,7 +74,7 @@
 
 void *tah_dump_regs(struct platform_device *ofdev, void *buf)
 {
-	struct tah_instance *dev = platform_get_drvdata(ofdev);
+	struct tah_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct emac_ethtool_regs_subhdr *hdr = buf;
 	struct tah_regs *regs = (struct tah_regs *)(hdr + 1);
 
@@ -119,7 +118,7 @@
 		goto err_free;
 	}
 
-	platform_set_drvdata(ofdev, dev);
+	dev_set_drvdata(&ofdev->dev, dev);
 
 	/* Initialize TAH and enable IPv4 checksum verification, no TSO yet */
 	tah_reset(ofdev);
@@ -138,7 +137,9 @@
 
 static int tah_remove(struct platform_device *ofdev)
 {
-	struct tah_instance *dev = platform_get_drvdata(ofdev);
+	struct tah_instance *dev = dev_get_drvdata(&ofdev->dev);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
 
 	WARN_ON(dev->users != 0);
 
@@ -148,7 +149,7 @@
 	return 0;
 }
 
-static const struct of_device_id tah_match[] =
+static struct of_device_id tah_match[] =
 {
 	{
 		.compatible	= "ibm,tah",
@@ -163,6 +164,7 @@
 static struct platform_driver tah_driver = {
 	.driver = {
 		.name = "emac-tah",
+		.owner = THIS_MODULE,
 		.of_match_table = tah_match,
 	},
 	.probe = tah_probe,
diff --git a/drivers/net/ethernet/ibm/emac/tah.h b/drivers/net/ethernet/ibm/emac/tah.h
--- a/drivers/net/ethernet/ibm/emac/tah.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/tah.h	2015-09-24 17:47:25.000000000 +0200
@@ -72,13 +72,13 @@
 
 #ifdef CONFIG_IBM_EMAC_TAH
 
-int tah_init(void);
-void tah_exit(void);
-int tah_attach(struct platform_device *ofdev, int channel);
-void tah_detach(struct platform_device *ofdev, int channel);
-void tah_reset(struct platform_device *ofdev);
-int tah_get_regs_len(struct platform_device *ofdev);
-void *tah_dump_regs(struct platform_device *ofdev, void *buf);
+extern int tah_init(void);
+extern void tah_exit(void);
+extern int tah_attach(struct platform_device *ofdev, int channel);
+extern void tah_detach(struct platform_device *ofdev, int channel);
+extern void tah_reset(struct platform_device *ofdev);
+extern int tah_get_regs_len(struct platform_device *ofdev);
+extern void *tah_dump_regs(struct platform_device *ofdev, void *buf);
 
 #else
 
diff --git a/drivers/net/ethernet/ibm/emac/zmii.c b/drivers/net/ethernet/ibm/emac/zmii.c
--- a/drivers/net/ethernet/ibm/emac/zmii.c	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/zmii.c	2015-09-24 17:47:25.000000000 +0200
@@ -24,7 +24,6 @@
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/ethtool.h>
-#include <linux/of_address.h>
 #include <asm/io.h>
 
 #include "emac.h"
@@ -85,7 +84,7 @@
 
 int zmii_attach(struct platform_device *ofdev, int input, int *mode)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct zmii_regs __iomem *p = dev->base;
 
 	ZMII_DBG(dev, "init(%d, %d)" NL, input, *mode);
@@ -151,7 +150,7 @@
 
 void zmii_get_mdio(struct platform_device *ofdev, int input)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	u32 fer;
 
 	ZMII_DBG2(dev, "get_mdio(%d)" NL, input);
@@ -164,7 +163,7 @@
 
 void zmii_put_mdio(struct platform_device *ofdev, int input)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 
 	ZMII_DBG2(dev, "put_mdio(%d)" NL, input);
 	mutex_unlock(&dev->lock);
@@ -173,7 +172,7 @@
 
 void zmii_set_speed(struct platform_device *ofdev, int input, int speed)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	u32 ssr;
 
 	mutex_lock(&dev->lock);
@@ -194,7 +193,7 @@
 
 void zmii_detach(struct platform_device *ofdev, int input)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 
 	BUG_ON(!dev || dev->users == 0);
 
@@ -219,7 +218,7 @@
 
 void *zmii_dump_regs(struct platform_device *ofdev, void *buf)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
 	struct emac_ethtool_regs_subhdr *hdr = buf;
 	struct zmii_regs *regs = (struct zmii_regs *)(hdr + 1);
 
@@ -273,7 +272,7 @@
 	printk(KERN_INFO
 	       "ZMII %s initialized\n", ofdev->dev.of_node->full_name);
 	wmb();
-	platform_set_drvdata(ofdev, dev);
+	dev_set_drvdata(&ofdev->dev, dev);
 
 	return 0;
 
@@ -285,7 +284,9 @@
 
 static int zmii_remove(struct platform_device *ofdev)
 {
-	struct zmii_instance *dev = platform_get_drvdata(ofdev);
+	struct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
 
 	WARN_ON(dev->users != 0);
 
@@ -295,7 +296,7 @@
 	return 0;
 }
 
-static const struct of_device_id zmii_match[] =
+static struct of_device_id zmii_match[] =
 {
 	{
 		.compatible	= "ibm,zmii",
@@ -310,6 +311,7 @@
 static struct platform_driver zmii_driver = {
 	.driver = {
 		.name = "emac-zmii",
+		.owner = THIS_MODULE,
 		.of_match_table = zmii_match,
 	},
 	.probe = zmii_probe,
diff --git a/drivers/net/ethernet/ibm/emac/zmii.h b/drivers/net/ethernet/ibm/emac/zmii.h
--- a/drivers/net/ethernet/ibm/emac/zmii.h	2017-10-05 13:25:17.769526572 +0200
+++ b/drivers/net/ethernet/ibm/emac/zmii.h	2015-09-24 17:47:25.000000000 +0200
@@ -53,15 +53,15 @@
 
 #ifdef CONFIG_IBM_EMAC_ZMII
 
-int zmii_init(void);
-void zmii_exit(void);
-int zmii_attach(struct platform_device *ofdev, int input, int *mode);
-void zmii_detach(struct platform_device *ofdev, int input);
-void zmii_get_mdio(struct platform_device *ofdev, int input);
-void zmii_put_mdio(struct platform_device *ofdev, int input);
-void zmii_set_speed(struct platform_device *ofdev, int input, int speed);
-int zmii_get_regs_len(struct platform_device *ocpdev);
-void *zmii_dump_regs(struct platform_device *ofdev, void *buf);
+extern int zmii_init(void);
+extern void zmii_exit(void);
+extern int zmii_attach(struct platform_device *ofdev, int input, int *mode);
+extern void zmii_detach(struct platform_device *ofdev, int input);
+extern void zmii_get_mdio(struct platform_device *ofdev, int input);
+extern void zmii_put_mdio(struct platform_device *ofdev, int input);
+extern void zmii_set_speed(struct platform_device *ofdev, int input, int speed);
+extern int zmii_get_regs_len(struct platform_device *ocpdev);
+extern void *zmii_dump_regs(struct platform_device *ofdev, void *buf);
 
 #else
 # define zmii_init()		0
diff --git a/drivers/net/ethernet/ibm/ibmveth.c b/drivers/net/ethernet/ibm/ibmveth.c
--- a/drivers/net/ethernet/ibm/ibmveth.c	2017-10-05 13:25:17.765526637 +0200
+++ b/drivers/net/ethernet/ibm/ibmveth.c	2015-09-24 17:47:25.000000000 +0200
@@ -12,7 +12,8 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * Copyright (C) IBM Corporation, 2003, 2010
  *
@@ -58,7 +59,7 @@
 
 static const char ibmveth_driver_name[] = "ibmveth";
 static const char ibmveth_driver_string[] = "IBM Power Virtual Ethernet Driver";
-#define ibmveth_driver_version "1.06"
+#define ibmveth_driver_version "1.04"
 
 MODULE_AUTHOR("Santiago Leon <santil@linux.vnet.ibm.com>");
 MODULE_DESCRIPTION("IBM Power Virtual Ethernet Driver");
@@ -79,11 +80,6 @@
 module_param(rx_flush, uint, 0644);
 MODULE_PARM_DESC(rx_flush, "Flush receive buffers before use");
 
-static bool old_large_send __read_mostly;
-module_param(old_large_send, bool, S_IRUGO);
-MODULE_PARM_DESC(old_large_send,
-	"Use old large send method on firmware that supports the new method");
-
 struct ibmveth_stat {
 	char name[ETH_GSTRING_LEN];
 	int offset;
@@ -105,9 +101,6 @@
 	{ "tx_send_failed", IBMVETH_STAT_OFF(tx_send_failed) },
 	{ "fw_enabled_ipv4_csum", IBMVETH_STAT_OFF(fw_ipv4_csum_support) },
 	{ "fw_enabled_ipv6_csum", IBMVETH_STAT_OFF(fw_ipv6_csum_support) },
-	{ "tx_large_packets", IBMVETH_STAT_OFF(tx_large_packets) },
-	{ "rx_large_packets", IBMVETH_STAT_OFF(rx_large_packets) },
-	{ "fw_enabled_large_send", IBMVETH_STAT_OFF(fw_large_send_support) }
 };
 
 /* simple methods of getting data from the current rxq entry */
@@ -137,11 +130,6 @@
 	return ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_OFF_MASK;
 }
 
-static inline int ibmveth_rxq_large_packet(struct ibmveth_adapter *adapter)
-{
-	return ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_LRG_PKT;
-}
-
 static inline int ibmveth_rxq_frame_length(struct ibmveth_adapter *adapter)
 {
 	return be32_to_cpu(adapter->rx_queue.queue_addr[adapter->rx_queue.index].length);
@@ -174,7 +162,7 @@
 	if (!pool->free_map)
 		return -1;
 
-	pool->dma_addr = kcalloc(pool->size, sizeof(dma_addr_t), GFP_KERNEL);
+	pool->dma_addr = kmalloc(sizeof(dma_addr_t) * pool->size, GFP_KERNEL);
 	if (!pool->dma_addr) {
 		kfree(pool->free_map);
 		pool->free_map = NULL;
@@ -192,6 +180,8 @@
 		return -1;
 	}
 
+	memset(pool->dma_addr, 0, sizeof(dma_addr_t) * pool->size);
+
 	for (i = 0; i < pool->size; ++i)
 		pool->free_map[i] = i;
 
@@ -303,18 +293,6 @@
 	atomic_add(buffers_added, &(pool->available));
 }
 
-/*
- * The final 8 bytes of the buffer list is a counter of frames dropped
- * because there was not a buffer in the buffer list capable of holding
- * the frame.
- */
-static void ibmveth_update_rx_no_buffer(struct ibmveth_adapter *adapter)
-{
-	__be64 *p = adapter->buffer_list_addr + 4096 - 8;
-
-	adapter->rx_no_buffer = be64_to_cpup(p);
-}
-
 /* replenish routine */
 static void ibmveth_replenish_task(struct ibmveth_adapter *adapter)
 {
@@ -330,7 +308,8 @@
 			ibmveth_replenish_buffer_pool(adapter, pool);
 	}
 
-	ibmveth_update_rx_no_buffer(adapter);
+	adapter->rx_no_buffer = *(u64 *)(((char*)adapter->buffer_list_addr) +
+						4096 - 8);
 }
 
 /* empty and free ana buffer pool - also used to do cleanup in error paths */
@@ -720,7 +699,8 @@
 
 	free_irq(netdev->irq, netdev);
 
-	ibmveth_update_rx_no_buffer(adapter);
+	adapter->rx_no_buffer = *(u64 *)(((char *)adapter->buffer_list_addr) +
+						4096 - 8);
 
 	ibmveth_cleanup(adapter);
 
@@ -766,7 +746,7 @@
 	 */
 
 	if (!(features & NETIF_F_RXCSUM))
-		features &= ~NETIF_F_CSUM_MASK;
+		features &= ~NETIF_F_ALL_CSUM;
 
 	return features;
 }
@@ -857,92 +837,21 @@
 	return rc1 ? rc1 : rc2;
 }
 
-static int ibmveth_set_tso(struct net_device *dev, u32 data)
-{
-	struct ibmveth_adapter *adapter = netdev_priv(dev);
-	unsigned long set_attr, clr_attr, ret_attr;
-	long ret1, ret2;
-	int rc1 = 0, rc2 = 0;
-	int restart = 0;
-
-	if (netif_running(dev)) {
-		restart = 1;
-		adapter->pool_config = 1;
-		ibmveth_close(dev);
-		adapter->pool_config = 0;
-	}
-
-	set_attr = 0;
-	clr_attr = 0;
-
-	if (data)
-		set_attr = IBMVETH_ILLAN_LRG_SR_ENABLED;
-	else
-		clr_attr = IBMVETH_ILLAN_LRG_SR_ENABLED;
-
-	ret1 = h_illan_attributes(adapter->vdev->unit_address, 0, 0, &ret_attr);
-
-	if (ret1 == H_SUCCESS && (ret_attr & IBMVETH_ILLAN_LRG_SND_SUPPORT) &&
-	    !old_large_send) {
-		ret2 = h_illan_attributes(adapter->vdev->unit_address, clr_attr,
-					  set_attr, &ret_attr);
-
-		if (ret2 != H_SUCCESS) {
-			netdev_err(dev, "unable to change tso settings. %d rc=%ld\n",
-				   data, ret2);
-
-			h_illan_attributes(adapter->vdev->unit_address,
-					   set_attr, clr_attr, &ret_attr);
-
-			if (data == 1)
-				dev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
-			rc1 = -EIO;
-
-		} else {
-			adapter->fw_large_send_support = data;
-			adapter->large_send = data;
-		}
-	} else {
-		/* Older firmware version of large send offload does not
-		 * support tcp6/ipv6
-		 */
-		if (data == 1) {
-			dev->features &= ~NETIF_F_TSO6;
-			netdev_info(dev, "TSO feature requires all partitions to have updated driver");
-		}
-		adapter->large_send = data;
-	}
-
-	if (restart)
-		rc2 = ibmveth_open(dev);
-
-	return rc1 ? rc1 : rc2;
-}
-
 static int ibmveth_set_features(struct net_device *dev,
 	netdev_features_t features)
 {
 	struct ibmveth_adapter *adapter = netdev_priv(dev);
 	int rx_csum = !!(features & NETIF_F_RXCSUM);
-	int large_send = !!(features & (NETIF_F_TSO | NETIF_F_TSO6));
-	int rc1 = 0, rc2 = 0;
+	int rc;
 
-	if (rx_csum != adapter->rx_csum) {
-		rc1 = ibmveth_set_csum_offload(dev, rx_csum);
-		if (rc1 && !adapter->rx_csum)
-			dev->features =
-				features & ~(NETIF_F_CSUM_MASK |
-					     NETIF_F_RXCSUM);
-	}
+	if (rx_csum == adapter->rx_csum)
+		return 0;
 
-	if (large_send != adapter->large_send) {
-		rc2 = ibmveth_set_tso(dev, large_send);
-		if (rc2 && !adapter->large_send)
-			dev->features =
-				features & ~(NETIF_F_TSO | NETIF_F_TSO6);
-	}
+	rc = ibmveth_set_csum_offload(dev, rx_csum);
+	if (rc && !adapter->rx_csum)
+		dev->features = features & ~(NETIF_F_ALL_CSUM | NETIF_F_RXCSUM);
 
-	return rc1 ? rc1 : rc2;
+	return rc;
 }
 
 static void ibmveth_get_strings(struct net_device *dev, u32 stringset, u8 *data)
@@ -993,7 +902,7 @@
 #define page_offset(v) ((unsigned long)(v) & ((1 << 12) - 1))
 
 static int ibmveth_send(struct ibmveth_adapter *adapter,
-			union ibmveth_buf_desc *descs, unsigned long mss)
+			union ibmveth_buf_desc *descs)
 {
 	unsigned long correlator;
 	unsigned int retry_count;
@@ -1010,8 +919,7 @@
 					     descs[0].desc, descs[1].desc,
 					     descs[2].desc, descs[3].desc,
 					     descs[4].desc, descs[5].desc,
-					     correlator, &correlator, mss,
-					     adapter->fw_large_send_support);
+					     correlator, &correlator);
 	} while ((ret == H_BUSY) && (retry_count--));
 
 	if (ret != H_SUCCESS && ret != H_DROPPED) {
@@ -1032,7 +940,6 @@
 	int last, i;
 	int force_bounce = 0;
 	dma_addr_t dma_addr;
-	unsigned long mss = 0;
 
 	/*
 	 * veth handles a maximum of 6 segments including the header, so
@@ -1058,9 +965,6 @@
 
 	desc_flags = IBMVETH_BUF_VALID;
 
-	if (skb_is_gso(skb) && adapter->fw_large_send_support)
-		desc_flags |= IBMVETH_BUF_LRG_SND;
-
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		unsigned char *buf = skb_transport_header(skb) +
 						skb->csum_offset;
@@ -1088,7 +992,7 @@
 		descs[0].fields.flags_len = desc_flags | skb->len;
 		descs[0].fields.address = adapter->bounce_buffer_dma;
 
-		if (ibmveth_send(adapter, descs, 0)) {
+		if (ibmveth_send(adapter, descs)) {
 			adapter->tx_send_failed++;
 			netdev->stats.tx_dropped++;
 		} else {
@@ -1122,23 +1026,7 @@
 		descs[i+1].fields.address = dma_addr;
 	}
 
-	if (skb_is_gso(skb)) {
-		if (adapter->fw_large_send_support) {
-			mss = (unsigned long)skb_shinfo(skb)->gso_size;
-			adapter->tx_large_packets++;
-		} else if (!skb_is_gso_v6(skb)) {
-			/* Put -1 in the IP checksum to tell phyp it
-			 * is a largesend packet. Put the mss in
-			 * the TCP checksum.
-			 */
-			ip_hdr(skb)->check = 0xffff;
-			tcp_hdr(skb)->check =
-				cpu_to_be16(skb_shinfo(skb)->gso_size);
-			adapter->tx_large_packets++;
-		}
-	}
-
-	if (ibmveth_send(adapter, descs, mss)) {
+	if (ibmveth_send(adapter, descs)) {
 		adapter->tx_send_failed++;
 		netdev->stats.tx_dropped++;
 	} else {
@@ -1157,7 +1045,7 @@
 			       DMA_TO_DEVICE);
 
 out:
-	dev_consume_skb_any(skb);
+	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
 
 map_failed_frags:
@@ -1171,61 +1059,11 @@
 	if (!firmware_has_feature(FW_FEATURE_CMO))
 		netdev_err(netdev, "tx: unable to map xmit buffer\n");
 	adapter->tx_map_failed++;
-	if (skb_linearize(skb)) {
-		netdev->stats.tx_dropped++;
-		goto out;
-	}
+	skb_linearize(skb);
 	force_bounce = 1;
 	goto retry_bounce;
 }
 
-static void ibmveth_rx_mss_helper(struct sk_buff *skb, u16 mss, int lrg_pkt)
-{
-	struct tcphdr *tcph;
-	int offset = 0;
-	int hdr_len;
-
-	/* only TCP packets will be aggregated */
-	if (skb->protocol == htons(ETH_P_IP)) {
-		struct iphdr *iph = (struct iphdr *)skb->data;
-
-		if (iph->protocol == IPPROTO_TCP) {
-			offset = iph->ihl * 4;
-			skb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;
-		} else {
-			return;
-		}
-	} else if (skb->protocol == htons(ETH_P_IPV6)) {
-		struct ipv6hdr *iph6 = (struct ipv6hdr *)skb->data;
-
-		if (iph6->nexthdr == IPPROTO_TCP) {
-			offset = sizeof(struct ipv6hdr);
-			skb_shinfo(skb)->gso_type = SKB_GSO_TCPV6;
-		} else {
-			return;
-		}
-	} else {
-		return;
-	}
-	/* if mss is not set through Large Packet bit/mss in rx buffer,
-	 * expect that the mss will be written to the tcp header checksum.
-	 */
-	tcph = (struct tcphdr *)(skb->data + offset);
-	if (lrg_pkt) {
-		skb_shinfo(skb)->gso_size = mss;
-	} else if (offset) {
-		skb_shinfo(skb)->gso_size = ntohs(tcph->check);
-		tcph->check = 0;
-	}
-
-	if (skb_shinfo(skb)->gso_size) {
-		hdr_len = offset + tcph->doff * 4;
-		skb_shinfo(skb)->gso_segs =
-				DIV_ROUND_UP(skb->len - hdr_len,
-					     skb_shinfo(skb)->gso_size);
-	}
-}
-
 static int ibmveth_poll(struct napi_struct *napi, int budget)
 {
 	struct ibmveth_adapter *adapter =
@@ -1233,11 +1071,9 @@
 	struct net_device *netdev = adapter->netdev;
 	int frames_processed = 0;
 	unsigned long lpar_rc;
-	struct iphdr *iph;
-	u16 mss = 0;
 
 restart_poll:
-	while (frames_processed < budget) {
+	do {
 		if (!ibmveth_rxq_pending_buffer(adapter))
 			break;
 
@@ -1252,21 +1088,9 @@
 			int length = ibmveth_rxq_frame_length(adapter);
 			int offset = ibmveth_rxq_frame_offset(adapter);
 			int csum_good = ibmveth_rxq_csum_good(adapter);
-			int lrg_pkt = ibmveth_rxq_large_packet(adapter);
 
 			skb = ibmveth_rxq_get_buffer(adapter);
 
-			/* if the large packet bit is set in the rx queue
-			 * descriptor, the mss will be written by PHYP eight
-			 * bytes from the start of the rx buffer, which is
-			 * skb->data at this stage
-			 */
-			if (lrg_pkt) {
-				__be64 *rxmss = (__be64 *)(skb->data + 8);
-
-				mss = (u16)be64_to_cpu(*rxmss);
-			}
-
 			new_skb = NULL;
 			if (length < rx_copybreak)
 				new_skb = netdev_alloc_skb(netdev, length);
@@ -1289,39 +1113,20 @@
 			skb_put(skb, length);
 			skb->protocol = eth_type_trans(skb, netdev);
 
-			if (csum_good) {
+			if (csum_good)
 				skb->ip_summed = CHECKSUM_UNNECESSARY;
-				if (be16_to_cpu(skb->protocol) == ETH_P_IP) {
-					iph = (struct iphdr *)skb->data;
 
-					/* If the IP checksum is not offloaded and if the packet
-					 *  is large send, the checksum must be rebuilt.
-					 */
-					if (iph->check == 0xffff) {
-						iph->check = 0;
-						iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
-					}
-				}
-			}
-
-			if (length > netdev->mtu + ETH_HLEN) {
-				ibmveth_rx_mss_helper(skb, mss, lrg_pkt);
-				adapter->rx_large_packets++;
-			}
-
-			napi_gro_receive(napi, skb);	/* send it up */
+			netif_receive_skb(skb);	/* send it up */
 
 			netdev->stats.rx_packets++;
 			netdev->stats.rx_bytes += length;
 			frames_processed++;
 		}
-	}
+	} while (frames_processed < budget);
 
 	ibmveth_replenish_task(adapter);
 
 	if (frames_processed < budget) {
-		napi_complete(napi);
-
 		/* We think we are done - reenable interrupts,
 		 * then check once more to make sure we are done.
 		 */
@@ -1330,6 +1135,8 @@
 
 		BUG_ON(lpar_rc != H_SUCCESS);
 
+		napi_complete(napi);
+
 		if (ibmveth_rxq_pending_buffer(adapter) &&
 		    napi_reschedule(napi)) {
 			lpar_rc = h_vio_signal(adapter->vdev->unit_address,
@@ -1418,8 +1225,11 @@
 	int i, rc;
 	int need_restart = 0;
 
+	if (new_mtu < IBMVETH_MIN_MTU)
+		return -EINVAL;
+
 	for (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++)
-		if (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size)
+		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size)
 			break;
 
 	if (i == IBMVETH_NUM_BUFF_POOLS)
@@ -1438,7 +1248,7 @@
 	for (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {
 		adapter->rx_buff_pool[i].active = 1;
 
-		if (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size) {
+		if (new_mtu_oh < adapter->rx_buff_pool[i].buff_size) {
 			dev->mtu = new_mtu;
 			vio_cmo_set_dev_desired(viodev,
 						ibmveth_get_desired_dma
@@ -1508,28 +1318,6 @@
 	return ret;
 }
 
-static int ibmveth_set_mac_addr(struct net_device *dev, void *p)
-{
-	struct ibmveth_adapter *adapter = netdev_priv(dev);
-	struct sockaddr *addr = p;
-	u64 mac_address;
-	int rc;
-
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	mac_address = ibmveth_encode_mac_addr(addr->sa_data);
-	rc = h_change_logical_lan_mac(adapter->vdev->unit_address, mac_address);
-	if (rc) {
-		netdev_err(adapter->netdev, "h_change_logical_lan_mac failed with rc=%d\n", rc);
-		return rc;
-	}
-
-	ether_addr_copy(dev->dev_addr, addr->sa_data);
-
-	return 0;
-}
-
 static const struct net_device_ops ibmveth_netdev_ops = {
 	.ndo_open		= ibmveth_open,
 	.ndo_stop		= ibmveth_close,
@@ -1540,7 +1328,7 @@
 	.ndo_fix_features	= ibmveth_fix_features,
 	.ndo_set_features	= ibmveth_set_features,
 	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_set_mac_address    = ibmveth_set_mac_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= ibmveth_poll_controller,
 #endif
@@ -1553,8 +1341,6 @@
 	struct ibmveth_adapter *adapter;
 	unsigned char *mac_addr_p;
 	unsigned int *mcastFilterSize_p;
-	long ret;
-	unsigned long ret_attr;
 
 	dev_dbg(&dev->dev, "entering ibmveth_probe for UA 0x%x\n",
 		dev->unit_address);
@@ -1601,33 +1387,12 @@
 	netdev->netdev_ops = &ibmveth_netdev_ops;
 	netdev->ethtool_ops = &netdev_ethtool_ops;
 	SET_NETDEV_DEV(netdev, &dev->dev);
-	netdev->hw_features = NETIF_F_SG;
-	if (vio_get_attribute(dev, "ibm,illan-options", NULL) != NULL) {
-		netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				       NETIF_F_RXCSUM;
-	}
-
+	netdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |
+		NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	netdev->features |= netdev->hw_features;
 
-	ret = h_illan_attributes(adapter->vdev->unit_address, 0, 0, &ret_attr);
-
-	/* If running older firmware, TSO should not be enabled by default */
-	if (ret == H_SUCCESS && (ret_attr & IBMVETH_ILLAN_LRG_SND_SUPPORT) &&
-	    !old_large_send) {
-		netdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
-		netdev->features |= netdev->hw_features;
-	} else {
-		netdev->hw_features |= NETIF_F_TSO;
-	}
-
-	netdev->min_mtu = IBMVETH_MIN_MTU;
-	netdev->max_mtu = ETH_MAX_MTU;
-
 	memcpy(netdev->dev_addr, mac_addr_p, ETH_ALEN);
 
-	if (firmware_has_feature(FW_FEATURE_CMO))
-		memcpy(pool_count, pool_count_cmo, sizeof(pool_count));
-
 	for (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {
 		struct kobject *kobj = &adapter->rx_buff_pool[i].kobj;
 		int error;
diff --git a/drivers/net/ethernet/ibm/ibmveth.h b/drivers/net/ethernet/ibm/ibmveth.h
--- a/drivers/net/ethernet/ibm/ibmveth.h	2017-10-05 13:25:17.765526637 +0200
+++ b/drivers/net/ethernet/ibm/ibmveth.h	2015-09-24 17:47:25.000000000 +0200
@@ -12,7 +12,8 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
  * Copyright (C) IBM Corporation, 2003, 2010
  *
@@ -40,8 +41,6 @@
 #define IbmVethMcastRemoveFilter     0x2UL
 #define IbmVethMcastClearFilterTable 0x3UL
 
-#define IBMVETH_ILLAN_LRG_SR_ENABLED	0x0000000000010000UL
-#define IBMVETH_ILLAN_LRG_SND_SUPPORT	0x0000000000008000UL
 #define IBMVETH_ILLAN_PADDED_PKT_CSUM	0x0000000000002000UL
 #define IBMVETH_ILLAN_TRUNK_PRI_MASK	0x0000000000000F00UL
 #define IBMVETH_ILLAN_IPV6_TCP_CSUM		0x0000000000000004UL
@@ -61,20 +60,13 @@
 static inline long h_send_logical_lan(unsigned long unit_address,
 		unsigned long desc1, unsigned long desc2, unsigned long desc3,
 		unsigned long desc4, unsigned long desc5, unsigned long desc6,
-		unsigned long corellator_in, unsigned long *corellator_out,
-		unsigned long mss, unsigned long large_send_support)
+		unsigned long corellator_in, unsigned long *corellator_out)
 {
 	long rc;
 	unsigned long retbuf[PLPAR_HCALL9_BUFSIZE];
 
-	if (large_send_support)
-		rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address,
-				  desc1, desc2, desc3, desc4, desc5, desc6,
-				  corellator_in, mss);
-	else
-		rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address,
-				  desc1, desc2, desc3, desc4, desc5, desc6,
-				  corellator_in);
+	rc = plpar_hcall9(H_SEND_LOGICAL_LAN, retbuf, unit_address, desc1,
+			desc2, desc3, desc4, desc5, desc6, corellator_in);
 
 	*corellator_out = retbuf[0];
 
@@ -113,8 +105,7 @@
 
 static int pool_size[] = { 512, 1024 * 2, 1024 * 16, 1024 * 32, 1024 * 64 };
 static int pool_count[] = { 256, 512, 256, 256, 256 };
-static int pool_count_cmo[] = { 256, 512, 256, 256, 64 };
-static int pool_active[] = { 1, 1, 0, 0, 1};
+static int pool_active[] = { 1, 1, 0, 0, 0};
 
 #define IBM_VETH_INVALID_MAP ((u16)0xffff)
 
@@ -156,13 +147,11 @@
     struct ibmveth_rx_q rx_queue;
     int pool_config;
     int rx_csum;
-    int large_send;
     void *bounce_buffer;
     dma_addr_t bounce_buffer_dma;
 
     u64 fw_ipv6_csum_support;
     u64 fw_ipv4_csum_support;
-    u64 fw_large_send_support;
     /* adapter specific stats */
     u64 replenish_task_cycles;
     u64 replenish_no_mem;
@@ -172,8 +161,6 @@
     u64 rx_no_buffer;
     u64 tx_map_failed;
     u64 tx_send_failed;
-    u64 tx_large_packets;
-    u64 rx_large_packets;
 };
 
 /*
@@ -193,7 +180,6 @@
 #endif
 #define IBMVETH_BUF_VALID	0x80000000
 #define IBMVETH_BUF_TOGGLE	0x40000000
-#define IBMVETH_BUF_LRG_SND     0x04000000
 #define IBMVETH_BUF_NO_CSUM	0x02000000
 #define IBMVETH_BUF_CSUM_GOOD	0x01000000
 #define IBMVETH_BUF_LEN_MASK	0x00FFFFFF
@@ -209,7 +195,6 @@
 #define IBMVETH_RXQ_TOGGLE		0x80000000
 #define IBMVETH_RXQ_TOGGLE_SHIFT	31
 #define IBMVETH_RXQ_VALID		0x40000000
-#define IBMVETH_RXQ_LRG_PKT		0x04000000
 #define IBMVETH_RXQ_NO_CSUM		0x02000000
 #define IBMVETH_RXQ_CSUM_GOOD		0x01000000
 #define IBMVETH_RXQ_OFF_MASK		0x0000FFFF
Only in a/drivers/net/ethernet/ibm: ibmvnic.c
Only in a/drivers/net/ethernet/ibm: ibmvnic.h
diff --git a/drivers/net/ethernet/ibm/Kconfig b/drivers/net/ethernet/ibm/Kconfig
--- a/drivers/net/ethernet/ibm/Kconfig	2017-10-05 13:25:17.765526637 +0200
+++ b/drivers/net/ethernet/ibm/Kconfig	2015-09-24 17:47:25.000000000 +0200
@@ -5,9 +5,12 @@
 config NET_VENDOR_IBM
 	bool "IBM devices"
 	default y
-	depends on PPC_PSERIES || PPC_DCR || (IBMEBUS && SPARSEMEM)
+	depends on MCA || PPC_PSERIES || PPC_PSERIES || PPC_DCR || \
+		   (IBMEBUS && SPARSEMEM)
 	---help---
-	  If you have a network (Ethernet) card belonging to this class, say Y.
+	  If you have a network (Ethernet) card belonging to this class, say Y
+	  and read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
 
 	  Note that the answer to this question doesn't directly affect the
 	  kernel: saying N will just cause the configurator to skip all
@@ -37,14 +40,4 @@
 	  To compile the driver as a module, choose M here. The module
 	  will be called ehea.
 
-config IBMVNIC
-	tristate "IBM Virtual NIC support"
-	depends on PPC_PSERIES
-	---help---
-	  This driver supports Virtual NIC adapters on IBM i and IBM System p
-	  systems.
-
-	  To compile this driver as a module, choose M here. The module will
-	  be called ibmvnic.
-
 endif # NET_VENDOR_IBM
diff --git a/drivers/net/ethernet/ibm/Makefile b/drivers/net/ethernet/ibm/Makefile
--- a/drivers/net/ethernet/ibm/Makefile	2017-10-05 13:25:17.765526637 +0200
+++ b/drivers/net/ethernet/ibm/Makefile	2015-09-24 17:47:25.000000000 +0200
@@ -3,6 +3,5 @@
 #
 
 obj-$(CONFIG_IBMVETH) += ibmveth.o
-obj-$(CONFIG_IBMVNIC) += ibmvnic.o
 obj-$(CONFIG_IBM_EMAC) += emac/
 obj-$(CONFIG_EHEA) += ehea/

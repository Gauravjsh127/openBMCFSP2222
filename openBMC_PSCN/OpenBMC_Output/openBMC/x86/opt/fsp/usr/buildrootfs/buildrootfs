#!/usr/bin/env perl
#
# perl script for generating a root filesystem
# Original script is from zSeries,
# modified by Harald Freudenberger
# and Andreas Loeffler
#
# feel free to post change requests and
# improvements to <freude@de.ibm.com> or <aloeff@de.ibm.com>
#


use warnings;
use strict;
use Getopt::Long qw(:config default no_ignore_case bundling);

use Pod::Usage;
use File::Basename;
use File::Find;

use constant VERSION => "IBM buildrootfs version 2.5";

my $date = scalar localtime;

my $configdir  = "configs";		# Default path to series conf files
my $targetdir  = "rootfs";		# Default destination directory
my $configfile;
my $stripcmd;
my $objdumpcmd;

my @filesearchpath;

my %opts = ();
my $nochown = 0;		# do not exec any chown commands
my $verbose = 0;		# verbose mode

my @dirlist;			# List of directories
my @rdirlist;			# List of recursive directories
my @liblist;			# List of shared libraries
my @binlist;			# List of binaries
my @slinklist;			# List of symbolic links
my @filelist;			# List of other files
my @modlist;			# List of kernel modules
my @devlist;			# List of device nodes
my @cmdlist;			# List of commands
my @solinks;			# links to shared libs
my @missing;			# missing libs that get added automatically
# exclude lists only make sense if recursive dirs are given
my @excludedirs;		# List of directories that should be excluded
my @excludefiles;		# List of file that should be excluded

# Save binary and library name for checking
my %beenchecked;
my %required;
my %needs;
my %soname;
my %missing;

# userid and groupid mapping
my %passwd = ( root => 0, bin => 1, daemon => 2, nobody => 99, zfsp => 100 );
my %group  = ( root => 0, bin => 1, daemon => 2, nobody => 99, zfsp => 100 );

#-----------------------------------------------------------------------------
# Execute a command and die if this command was unsuccessful
sub myrun
{
     print "running \"@_\"\n" if $verbose > 3;
     system(@_) == 0 || die "$_[0] failed: $!. Stopped";
}

#-----------------------------------------------------------------------------

# functions to determine file type
sub filetype($) {
     my $f = $_[0];
     chomp(my $out = `file $f`);
     ($verbose > 3) && print "FILE: $out\n";
     die "file failed: $!, stopped" unless (0 == $?);
     my @out = split /:/, $out;

     return $out[1];
}
sub is_elf_exe($) {
     my $f = $_[0];
     $f    = filetype($f);
     return ($f =~ m/ELF.*executable/) ? 1 : 0;
}
sub is_elf_so($) {
     my $f = $_[0];
     $f    = filetype($f);
     return ($f =~ m/ELF.*shared object/) ? 1 : 0;
}
sub is_dev($) {
     my $f = $_[0];
     $f    = filetype($f);
     return ($f =~ m/[character|block] special/) ? 1 : 0;
}

sub exclude_dirs {
     return 0 unless $_[0];
     my $dir = $_[1];

     foreach (@excludedirs) {
	  if ($dir =~ m/^$_/) {
	       print "Matching exclude dir: $dir matched by $_!\n"
		    if $verbose > 3;
	       return 1;
	  }
     }
     return 0;
}
sub exclude_files {
     return 0 unless $_[0];
     my $file = $_[1];

     foreach (@excludefiles) {
	  if ($file =~ m/^$_/) {
	       print "Matching exclude file: $file matched by $_!\n"
		    if $verbose > 3;
	       return 1;
	  }
     }
     return exclude_dirs(1, $file);
}


#-----------------------------------------------------------------------------

# generate config file, in=directory name, out=config file name
# prefix is used if this is called for recursuve directory adds
sub gen_config {
     my $in  = shift;
     my $out = shift;
     my $prefix = shift;
     my (@liblist_, @solinks_, @modlist_, @slinklist_, @dirlist_, @binlist_,
	 @devlist_, @filelist_);
     my @unmatched;

     open CONF, ">$out" or die "could not open $out: $!\n";
     print CONF "# automatically generated by buildrootfs -r ($date)\n";
     print CONF "# cannot handle ~C please check for your own conf files\n\n";

     # strip leading '/' if any from input dir name
     $in =~ s/\/*$//;

     # read file list via find
     chomp(my @files = `find $in`);
     die "find failed: $!, stopped" unless (0 == $?);
     # find prints the path to the directory first, then follow the files
     shift @files;

     foreach (@files) {
	  my $file = $_;

	  s/$in//;
	  defined $prefix && ($_ = $prefix . $_);
	  print "in:$in, $file > $_\n" if $verbose > 2;

	  # directories
	  if (-d $file) {
	       ($verbose > 3) && print "-> dirlist\n";
	       next if (1 == exclude_dirs($prefix, $_));
	       print "pushing $_ to dirlist_\n" if $verbose > 3;
	       push @dirlist_, $_;
	       print CONF "dir $_ root.root 755\n";
	       next;
	  }
	  # so files that are not symlinks
	  if (m/.+\.so.*/ && is_elf_so($file)) {
	       ($verbose > 3) && print "-> .so liblist\n";
	       next if (1 == exclude_files($prefix, $_));
	       print "pushing $_ to liblist_\n" if $verbose > 3;
	       push @liblist_, $_;
	       print CONF "lib $_ root.root 755\n";
	       next;
	  }
	  # sort out so-symlinks
	  if (m/.+\.so\..*/ && -l $file) {
	       ($verbose > 3) && print "-> solink\n";
	       push @solinks_, $_;
	       next;
	  }
	  # static libs
	  if (m/.+\.a$/ && ! -l $file) {
	       ($verbose > 3) && print "-> .a liblist\n";
	       next if (1 == exclude_files($prefix, $_));
	       print "pushing $_ to liblist_\n" if $verbose > 3;
	       push @liblist_, $_;
	       print CONF "lib $_ root.root 644\n";
	       next;
	  }
	  # kernel modules
	  if (m/.+\.ko$/) {
	       ($verbose > 3) && print "-> .ko modlist\n";
	       next if (1 == exclude_files($prefix, $_));
	       print "pushing $_ to modlist_\n" if $verbose > 3;
	       push @modlist_, $_;
	       print CONF "mod $_ root.root 644\n";
	       next;
	  }
	  # symlinks
	  if (-l $file) {
	       my $linkto = readlink $file;
	       my $base = basename($_);
	       my $path = dirname($_);
	       ($verbose > 3) && print "-> slinklist\n";
	       push @slinklist_, $_;
	       print CONF "slink $linkto $_\n";
	       next;
	  }
	  # executables
	  if (-f $file && -x _) {
	       ($verbose > 3) && print "-> binlist\n";
	       next if (1 == exclude_files($prefix, $_));
	       print "pushing $_ to binlist_\n" if $verbose > 3;
	       push @binlist_, $_;
	       my $nostrip = is_elf_exe($file) ? "" : " ~ nostrip";
	       print CONF "bin $_ root.root 755$nostrip\n" ;
	       next;
	  }
	  # devices
	  if (is_dev($file)) {
	       ($verbose > 3) && print "-> devlist\n";
	       push @devlist_, $_;
	  }
	  if (-f $file && ! -x _) {
	       ($verbose > 3) && print "-> filelist\n";
	       next if (1 == exclude_files($prefix, $_));
	       print "pushing $_ to filelist_\n" if $verbose > 3;
	       push @filelist_, $_;
	       print CONF "file $_ root.root 644\n";
	       next;
	  }
	  # anything not matched ?
	  ($verbose > 2) && print "UNMATCHED\n";
	  push @unmatched, $_;

     }

     foreach (@unmatched) {
	  print "Not matched: $_\n";
     }
     if ($verbose > 1) {
	     print "Number of directories:  ", 1 + $#dirlist_,  "\n";
	     print "Number of devices:      ", 1 + $#devlist_,  "\n";
	     print "Number of files:        ", 1 + $#filelist_, "\n";
	     print "Number of modules:      ", 1 + $#modlist_,  "\n";
	     print "Number of binaries:     ", 1 + $#binlist_,  "\n";
	     print "Number of libraries:    ", 1 + $#liblist_,  "\n";
	     print "Number of so links:     ", 1 + $#solinks_,  "\n";
	     print "Number of symlinks:     ", 1 + $#slinklist_,"\n";
     }
     close CONF;
}

#-----------------------------------------------------------------------------

# Read the rootfs config file
sub readconfig($)
{
     my ($file) = (@_);
     local *CONFIG;
     open(CONFIG, $file) || die "Can not open file $file: $!";
     my $line;
     my @handlelist;
     my $filelist;
     my $handle = *CONFIG;
     while ( 1 ) {
	  if (eof $handle || not defined ($line = <$handle>)) {
	       close $handle;
	       if (scalar @handlelist) {
		    $handle = pop @handlelist;
		    $file = pop @filelist;
		    next;
	       } else {
		    last;
	       }
	  }
	  # Delete comment lines and empty lines
	  $line =~ s/^\s*//;	# remove leading whitespace
	  chomp $line;		# remove newline
	  next if ( $line =~ /^[#:;?]/ ); # a comment line, skip.
	  next if ( $line =~ /^\s*$/ );	  # empty line, skip.
	  $line =~ s/\s+#.*$//;		  # Delete trailing comment
	  $line =~ s/\s+$//;		  # Delete trailing whitespace
	  # split into type and arguments
	  if ($line !~ m/^\s*(\S*)\s*(.*)$/) {
	       die "cannot parse line '$line' from file '$file'\n";
	  }
	  my $type = $1;
	  my $args = $2;
	  print "readconfig: line=$line, type=$type, args=$args\n" if $verbose > 3;
	  if ($type eq 'dir') {	# Read directory entry
	       push @dirlist, $args;
	  } elsif ($type eq 'rdir') {	# Recursive read directory entry
	       $args =~ s/^(\/.*?)\/*\s*$/$1/; # remove trailing '/'
	       push @rdirlist, $args;
	  } elsif ($type eq '-dir') {	       # Exclude directory entry
	       $args =~ s/^(\/.*?)\/*\s*$/$1/; # remove trailing '/'
	       push @excludedirs, $args;
	  } elsif ($type eq '-file' || $type eq '-lib' || $type eq '-bin') {	# Exclude file entry
	       $args =~ s/^(.*?)\s+.*$/$1/;
	       push @excludefiles, $args;
	  } elsif ($type eq 'file') {	# Read file entry
	       push @filelist, $args;
	  } elsif ($type eq 'mod') {	# Read modul entry
	       push @modlist, $args;
	  } elsif ($type eq 'lib') {	# Read library entry
	       push @liblist, $args;
	  } elsif ($type eq 'bin') {	# Read application entry
	       push @binlist, $args;
	  } elsif ($type eq 'slink') {	# Read slink entry
	       push @slinklist, $args;
	  } elsif ($type eq 'dev') {	# Read dev entry
	       push @devlist, $args;
	  } elsif ($type eq 'cmd') {	# Read command entry
	       push @cmdlist, $args;
	  } elsif ($type eq 'include') {
	       push @handlelist, $handle;
	       push @filelist, $file;
	       $file = $args;
	       local *FH;
	       open(FH, $file) || die "cannot open file '$file' for include\n";
	       $handle = *FH;
	  } else {
	       die "unknown command '$type'\n";
	  }
     }
     close($handle);
}

#-----------------------------------------------------------------------------

# Check if targetname already exists and has the correct file type.
sub targetname($$)
{
     my ($type, $name) = (@_);
     if ( ! ($name =~ /^\//) ) {
	  die "target $name is not an absolute path";
     }
     my $newname = $targetdir . $name;
     if ( -e $newname ) {
	  if ( $type eq 'dir' && -d $newname && $verbose > 2 ) {
	       print "target directory $name already exists\n";
	  } elsif ( $type eq 'dir' && ! -d $newname ) {
	       die "target $name already exists but is not a directory\n";
	  } elsif ( $type eq 'file' && -f $newname && $verbose > 2 ) {
	       print "target file $name already exists\n";
	  } elsif ( $type eq 'file' && ! -f $newname ) {
	       die "target $name already exists but is not a plain file\n";
	  }
     }
     return $newname;
}

#-----------------------------------------------------------------------------

# Build source file name and check if it exists
sub sourcename($$)
{
	my ($name, $srcfile) = (@_);
	my $newname;
	if ($verbose > 2) {
		print "sourcename($name, ";
		printf("%s)\n", defined $srcfile ? $srcfile : "undef");
	}
	if ( ! defined $srcfile || $srcfile =~ /^~$/ ) {
		# srcfile is empty or ~
		# search for the file in all the dirs stored in @filesearchpath
		foreach my $x (@filesearchpath) {
			$newname = $x . "/" . $name;
			print "   checking $newname\n" if $verbose > 3;
			if ( -r $newname ) {
				print " $name found in dir \"$x\", new filename is \"$newname\"\n" if $verbose > 2;
				return $newname;
			}
			$newname = $x . "/" . `basename $name`;
			chop( $newname );
			print "   checking $newname\n" if $verbose > 3;
			if ( -r $newname ) {
				print " $name found in dir \"$x\", new filename is \"$newname\"\n" if $verbose > 2;
				return $newname;
			}
			if ($opts{autolibs}){
				$newname = $x . "/usr/" . $name;
				print "   checking $newname\n" if $verbose > 3;
				if ( -r $newname ) {
					print " $name found in dir \"$x\", new filename is \"$newname\"\n" if $verbose > 2;
					return $newname;
				}
			}
		}
		die "$name not found within filesearchpath (@filesearchpath)\n";
	}
	if ( $srcfile =~ /^~\// ) {
		# srcfile begins with ~/
		# search for the file in all the dirs stored in @filesearchpath
		$srcfile =~ s/^\~\///;
		foreach my $x (@filesearchpath) {
			$newname = $x . "/" . $srcfile;
			if ( -r $newname ) {
				print " $name found in dir \"$x\", new filename is \"$newname\"\n" if $verbose > 2;
				return $newname;
			}
		}
		die "$name not found within filesearchpath (@filesearchpath)\n";
	}
	if ( $srcfile =~ /^~C/ ) {
		# srcfile begins with ~C
		# search for the file in specified configdir
		$srcfile =~ s/^\~C//;
		print "srcfile = $srcfile\n" if ($verbose > 2);
		if ($srcfile) {
			$newname = $configdir . "/" . $srcfile;
		} else {
			$newname = $configdir . "/" . `basename $name`;
			chop($newname);
		}
		print "newname = $newname\n" if ($verbose > 2);
		if ( -r $newname ) {
			print " $name found in dir \"$configdir\", new filename is \"$newname\"\n" if $verbose > 1;
			return $newname;
		}
		die "$name not found within configdir ($configdir)\n";
	}
	if ( -r $srcfile ) {
		print "$srcfile exists" if $verbose > 2;
		return $srcfile;
	}
	die "$srcfile does not exist to copy to $name\n";
}

#-----------------------------------------------------------------------------

# Set the ownership of a file. The numeric values should be read from the
# passwd/group file in our config/ql8x directory. Since we have very little
# users and groups, this is hardcoded using hashes

sub mychown($$)
{
     my ($newowner, $name) = @_;
     my ($userid, $groupid);
     ($userid, $groupid) = split('\.', $newowner);
     #print "userid:$passwd{$userid} groupid:$group{$groupid} name:$name\n";
     my ( $a, $b) = ($passwd{$userid}, $group{$groupid});
     if( ! defined($a) || ! defined($b) )
	  { die "unknown owner $newowner for $name\n"; }
     my $changed = chown $a, $b,  "$name";
     if( $changed == 0 )
	  { die "can not set ownership of file $name to $newowner: $!"; }
}

#-----------------------------------------------------------------------------

# Create directory without setting ownership which requires root priviledges.
sub mymkdir
{
     my( $dirname, $dirowner, $dirmode ) = @_;
     my $to = targetname("dir", $dirname);
     if( ! $dirowner ) { $dirowner = "bin.bin"; }
     if( ! $dirmode ) { $dirmode = "755"; }
     print "mkdir $to\n" if $verbose > 1;
     my @cmd = ('mkdir', "-p", $to);
     myrun(@cmd);
     if( $nochown == 0 ) { mychown( $dirowner, $to ); }
     chmod oct($dirmode), $to || die "can not permissions for $dirname to $dirmode: $!";
}

#-----------------------------------------------------------------------------

# Create device node without setting ownership which requires root priviledges.
sub mymkdev
{
     my( $devname, $devtype, $devmajor, $devminor, $devowner, $devmode ) = @_;
     my $to = targetname("dev", $devname);
     if ( ! $devowner ) {
	  $devowner = "bin.bin";
     }
     if ( ! $devmode ) {
	  $devmode = "755";
     }
     print "mknod $to $devtype $devmajor $devminor\n" if $verbose > 1;
     if ($opts{nomknod}) {
	  print "skipping ... --nomknod option was set\n" if $verbose > 1;
	  return;
     }
     myrun("mknod $to $devtype $devmajor $devminor");
     if ( $nochown == 0 ) {
	  mychown( $devowner, $to );
     }
     chmod oct($devmode), $to || die "can not change permissions for $devname to $devmode: $!";
}

#-----------------------------------------------------------------------------

# Copy file without setting ownership which requires root priviledges.
sub mycp
{
     my( $name, $fileowner, $filemode, $srcname ) = @_;

     print "mycp: $name, $fileowner, $filemode, " if $verbose > 2;
     printf("%s\n", defined $srcname ? $srcname : "undef") if $verbose > 2;
     my $to = targetname("file", $name);
     my $topath = dirname($to);
     my $from = sourcename($name, $srcname);
     $fileowner = "bin.bin" unless $fileowner;
     print "mycp: to=$to, topath=$topath, from=$from\n" if $verbose > 2;
     die "No file permissions for $name" unless $filemode;

     if (! $opts{noautopath}) {
	  print "create topath: $topath\n" if $verbose > 1;
	  my @cmd = ('mkdir', "-p", $topath);
	  myrun(@cmd);
     }

     my @cmd = ('cp', "-f", $from, $to); # Force copy
     print "copy $from --> $to\n" if $verbose > 1;
     myrun(@cmd);
     if ( $nochown == 0 ) {
	  mychown($fileowner, $to);
     }
     chmod oct($filemode), $to || die "can not set permissions for $name to $filemode: $!";
     return $to;
}

#-----------------------------------------------------------------------------

# Find out all the dependencies of an application. Returns a string with
# libraries names. As a side effect, fill the soname hash. It contains the
# file name a shared library is known to the applications. This file name
# may be different than the real file name in the /lib directory.
sub finddeps($$)
{
     my( $app, $apporig ) = @_;
     my( $libname, $dep, $myname );
     $dep = "";
     print "trying to find all dependencies for $app\n" if $verbose > 2;
     if ( ! -e $app ) {
	  die "ERROR file $app does not exist\n";
     }
     open( FILE, "$objdumpcmd $app 2>/dev/null |" )
	  || die "ERROR running \"$objdumpcmd $app\"\n";
     while ( <FILE> ) {
	  ( $libname ) = /.*NEEDED\s*([^\s]+)\s*$/;
	  if ( $libname ) {
	       print "$apporig needs $libname\n" if $verbose > 1;
	       $dep = $dep . " " . $libname;
	  }
	  ( $myname ) = /.*SONAME\s*([^\s]+)\s*$/;
	  if ( $myname ) {
	       print "$apporig aliases to $myname\n" if $verbose > 1;
	       $soname{$apporig} = $myname;
	  }
     }
     close( FILE );
     # if( $dep && $verbose > 1) { print "$apporig dependencies: $dep\n" };
     return $dep;
}

#-----------------------------------------------------------------------------

# create symbolic link for .so files
sub mkslink($$) {
     my ($target, $linkname) = @_;

     my $target_dir  = dirname($target);
     my $target_base = basename($target);
     my $link_dir    = dirname($linkname);
     my $link_base   = basename($linkname);

     print "mkslink:  target='$target', linkname='$linkname'\n"
	  if $verbose > 3;

     # Return if old and new name are identical
     if ( $target_base eq $linkname ) {
	  print "Warn:  target ($target) eq linkname ($linkname), NO SYMLINK\n"
	       if $verbose > 3;
	  return;
     }

     # Make sure linkname has no relative path
     die "mkslink error: linkname has relative path: $linkname, stopped"
	  if ($linkname =~ /^\.\.?/);

     # is linkname an absolute path ?
     if ($link_dir =~ /^\//) {
	  $linkname = "$targetdir/$linkname";
     } else {			# linkname does not have a path
	  die "mkslink error: target has relative path ($target) and linkname " .
	       "does not have a path ($linkname), stopped" if ($target =~ /^\.\.?/);
	  $linkname = "$targetdir/$target_dir/$linkname";
     }

     # remove link if it already exist
     if ( -l $linkname ) {
	  unlink "$linkname" || die "can not remove symbolic link $linkname:$!";
     }

     # check if target exist at all
     my $checkme = ($target =~ /^\//) ? "$targetdir/$target" :
	  "$targetdir/$link_dir/$target";
     print "mkslink: checking if $checkme exist\n" if $verbose > 3;

     $target = ($target_dir eq $link_dir) ? $target_base : $target;
     print "mkslink: ln -s $target $linkname\n" if $verbose > 1;
     symlink ("$target", "$linkname") == 0
	  && warn "WARNING: can not create symbolic link $linkname -> $target: $!";
}

sub process_libs_n_bins {
	my @list = @_;
	print "process list:\n@list\n" if $verbose > 2;
	foreach my $x (@list) {
		print "processing from list: $x\n" if $verbose > 3;
		my ($file, $owner, $mode, $from, $options) = split(' ', $x);
		my $tofile = mycp($file, $owner, $mode, $from);
		$options = "" unless $options;
		if ( $options !~ /nocheck/ ) {
			$required{$file} = 1;
		} else {
			$required{$file} = 0;
		}
		$needs{$file} = finddeps($tofile, $file);
		if ( $options !~ /nostrip/ ) {
			myrun($stripcmd, "--strip-unneeded", $tofile);
		}
	}
}

sub mksonamelink {
	foreach my $x (sort keys %soname) {
		print "  sonamelist $x name $soname{$x}\n" if( $verbose > 2 );
		mkslink($x, $soname{$x});
	}

}

#-----------------------------------------------------------------------------

# Parsing command line arguments
sub parse_command_line($) {
     my $opt = shift;
     my $result = GetOptions( "help|h"		=> \$$opt{'help'},
			      "usage|u"		=> \$$opt{'usage'},
			      "man|m"		=> \$$opt{'man'},
			      "version|V"	=> sub { print VERSION . "\n"; exit 0; },
			      "verbose|v+"	=> \$$opt{'verbose'},
			      "debug"		=> \$$opt{'debug'},
			      "targetdir|t=s"   => \$$opt{'targetdir'},
			      "configfile|c=s"  => \$$opt{'configfile'},
			      "configdir|C=s"   => \$$opt{'configdir'},
			      "searchdir|s=s@"  => \$$opt{'searchdir'},
			      "cross=s"		=> \$$opt{'cross'},
			      "nochown"		=> \$$opt{'nochown'},
			      "nomknod"		=> \$$opt{'nomknod'},
			      "reverse|r"	=> \$$opt{'reverse'},
			      "autolibs"	=> \$$opt{'autolibs'},
			      "noautopath"	=> \$$opt{'noautopath'},
			      #"verify"          => \$$opt{'verify'}
			    ) or pod2usage(2);
     pod2usage(1) if defined $$opt{help};
     pod2usage(2) if defined $$opt{usage};
     pod2usage(-verbose => 2) if defined ($$opt{man});
     pod2usage(2) unless defined $$opt{'configfile'};
     pod2usage(2) unless (defined $$opt{'searchdir'} || defined $$opt{'reverse'});

     $verbose     = $$opt{'verbose'}   if defined $$opt{'verbose'};
     $verbose    += 10 if defined $$opt{'debug'};
}

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------

# process arguments
parse_command_line(\%opts);

$targetdir  = $opts{targetdir}  ? $opts{targetdir}  : $targetdir;
$configfile = $opts{configfile} ? $opts{configfile} : $configfile;
$configdir  = $opts{configdir}  ? $opts{configdir}  : $configdir;
$nochown    = $opts{nochown}    ? 1 : 0;
my $cross   = $opts{cross} ?
     ($opts{cross} eq 'native') ? '' : $opts{cross} :
     '/opt/mcp/ppcnf/bin/ppcnf-ibm-linux-gnu-';
$stripcmd   = $cross . 'strip';
$objdumpcmd = $cross . 'objdump -x';


unshift @filesearchpath, @{$opts{'searchdir'}} if defined $opts{'searchdir'};
# FIXME: remove non-existing directories from filesearchpath

# if --reverse | -r is given then build config file from given targetdir
if($opts{'reverse'}){
     print "Creating config file from filesystem tree in '$targetdir'\n";
     gen_config($targetdir, $configfile);
     print "...done\n";
     exit 0;
}

# read in config file
readconfig($configfile);

# remove target directory and create a new one
print "Creating root filesystem tree in \"$targetdir\"\n" if $verbose;
myrun( "rm -rf $targetdir" );
myrun( "mkdir $targetdir" );


my $temp = '/tmp/rdir.conf';
print "processing recursive directory list\n" if $verbose;
foreach my $dir (@rdirlist) {
     $dir =~ s/^(\/.*?)\/*\s+.*/$1/g;
     print "RDIR: $dir\n" if $verbose > 1;

     foreach my $x (@filesearchpath) {
	     my $rdir = $x . "/" . $dir;
	     print "Checking $rdir\n" if $verbose > 2;
	     if (-d $rdir) {
		     print "RDIR: $rdir found!\n" if $verbose > 2;
		     print "gen_config($rdir, $temp, $dir)\n" if $verbose > 2;
		     gen_config($rdir, $temp, $dir);
		     goto DIREND;
	     } else {
		     print "RDIR: $rdir not found or not a directory\n"
			  if $verbose > 1;
	     }
     }
   DIREND:
     print "Read temp config file, reconfigure file lists for rdir: $dir\n"
	  if $verbose;
     readconfig($temp);
}
unlink $temp;

# process all dirs in the dirlist
print "processing directory list\n" if $verbose;
foreach (@dirlist) {
     mymkdir(split /\s+/)
}

# process all devices in the devlist
print "processing device list\n" if $verbose;
foreach (@devlist) {
     mymkdev(split /\s+/)
}

# process all files in the filelist
print "processing file list\n" if $verbose;
foreach my $x (@filelist) {
	print "filelist: '$x'\n" if $verbose > 2;
	my ($file, $owner, $mode, $from, $options) = split(' ', $x);
	my $tofile = mycp($file, $owner, $mode, $from);
}

# process all the kernel modules
print "processing kernel modul list\n" if $verbose;
foreach my $x (@modlist) {
     my ($file, $owner, $mode, $from, $options) = split(' ', $x);
     if ($verbose > 3) {
	  printf "MODULE: $x\n";
	  printf "file:$file\n";
	  printf "owner:$owner\n";
	  printf "mode:$mode\n";
	  printf "from:$from\n" if $from;
	  printf "options:$options\n" if $options;
     }
     $options = "" unless $options;
     my $tofile = mycp($file, $owner, $mode, $from);
     if ( $options !~ /nostrip/ ) {
	  myrun( $stripcmd, "--strip-debug", $tofile);
     }
}

# Read libraries and binaries. Add into list of reference checking.
print "processing lib and bin lists\n" if $verbose;
process_libs_n_bins(@liblist);
process_libs_n_bins(@binlist);

print "Create symbolic links for shared libraries\n" if $verbose;
mksonamelink();

# Read symbolic links
print "processing slink list\n" if $verbose;
foreach my $x (@slinklist) {
     my ($oldfile, @news) = split(' ', $x);
     foreach my $y (@news) {
	  mkslink($oldfile, $y);
     }
}

# need these global to pass data in and out of wanted
# other suggestions/comments welcome !
my $find_me;
my $found_you;
print "Cross check for libraries\n" if $verbose;
foreach my $x (sort keys %needs) {
     print "  $x requires $needs{$x}\n" if( $verbose > 2 );
     print "  checking $x:\n" if $verbose > 2;
     $beenchecked{$x} = 0;
     foreach my $y (split(' ', $needs{$x})) {
	  # print "member:$y\n";
	  print "  checking for $targetdir/lib/$y\n" if $verbose > 2;
	  lstat("$targetdir/lib/$y");
	  if ( -r _ ) {
	       $beenchecked{$x} = 1;
	       next;
	  }
	  print "  checking for $targetdir/usr/lib/$y\n" if $verbose > 2;
	  lstat("$targetdir/usr/lib/$y");
	  if ( -r _ ) {
	       $beenchecked{$x} = 1;
	       next;
	  }
	  print "  checking for $targetdir/lib64/$y\n" if $verbose > 2;
	  lstat("$targetdir/lib64/$y");
	  if( -r _ ) {
		  $beenchecked{$x} = 1;
		  next;
	  }
	  print "  checking for $targetdir/usr/lib64/$y\n" if $verbose > 2;
	  lstat("$targetdir/usr/lib64/$y");
	  if( -r _ ) {
		  $beenchecked{$x} = 1;
		  next;
	  }
	  die "ERROR: File $x requires missing file $y" unless $opts{autolibs};

	  $find_me   = $y;
	  $found_you = undef;
	  next if $missing{$y};

	  print "Trying to get missing $y required by $x\n" if $verbose > 1;
	  find({wanted => \&wanted}, @filesearchpath);
	  die "ERROR: File $x requires missing file $y" unless $found_you;
	  my $lib = basename($found_you);
	  my $libpath = dirname($found_you);
	  print "found_you=$found_you, lib=$lib, libpath=$libpath\n" if $verbose > 3;
	  print "found it '$lib'\n" if $verbose > 1;
	  $missing{$find_me} = $lib;
	  my $addlib = sprintf("/lib/%s root.root 644", $lib);
	  push @missing, $addlib;
     }
}

sub wanted {
	/$find_me/ && -f && ($found_you = $File::Find::name);
	/$find_me/ && -l && ($found_you = $File::Find::dir . "/" . readlink);
}

# reset %soname to process remaining links if any
%soname = ();
process_libs_n_bins(@missing);
print "Create symbolic links for auto added shared libraries\n" if $verbose;
mksonamelink();

foreach my $x (sort keys %needs) {
     print "Warning $x not needed\n" if ! $beenchecked{$x} && ! $required{$x};
}

# process all commands in the cmdlist
print "processing command list\n" if $verbose > 2;
foreach my $x (@cmdlist) {
     my $cmd="cd $targetdir && $x";
     myrun( $cmd );
}


SUMMARY:
# print out summary information
print "\nSummary\n";
print "Number of directories:             ", 1 + $#dirlist,  "\n";
print "Number of devices:                 ", 1 + $#devlist, "\n";
print "Number of files:                   ", 1 + $#filelist, "\n";
print "Number of modules:                 ", 1 + $#modlist,  "\n";
print "Number of binaries:                ", 1 + $#binlist,  "\n";
print "Number of libraries:               ", 1 + $#liblist,  "\n";
print "Number of so links:                ", 1 + $#solinks,  "\n";
print "Number of symlinks:                ", 1 + $#slinklist,"\n";
print "Number of missing libraries added: ", 1 + $#missing,  "\n";
print "Number of excluded directories:    ", 1 + $#excludedirs, "\n";
print "Number of excluded files:          ", 1 + $#excludefiles,"\n";


__END__




=head1 NAME

    buildrootfs - Using GetOpt::Long, Pod::Usage


=head1 SYNOPSIS

    buildrootfs -c,--configfile FILE -s,--searchdir DIR [OPTIONS ...]


    OPTION

    [-h,--help] [-u,--usage] [-m,--man] [-v,--verbose] [-V,--version]
    [-t,--targetdir DIR] [-C,--configdir DIR]
    [--nochown] [--nomknod] [--noautopath] [--autolibs]
    [--cross CROSS_COMPILE_PREFIX] [-r,--reverse]

=head1 ABSTRACT

    Perl script for generating a root filesystem.

=head2 Details

    This script can be used to setup a root filesystem tree.
    From such tree you can then create image files like initial
    ramdisk to mount when booting an linux image.
    The script reads the root file systems content from a configuration
    file (--configfile) and places the rootfs  tree in the target
    directory (--targetdir).
    The source path (or in other terms the search path) from where those
    files should be copied can be specified via the --searchdir option.
    Additionally you can specify an extra directory via --configdir from
    where configuration files can be copied into the rootfs (instead of
    copying those files with same name from one of the search dirs).
    You can also create an config file from a given directory tree using
    the --reverse option.
    During copying of an application or lib the dependencies for this
    object are examined and stored in a list. When the rootfs is done
    this list is further examined to determine if there are some
    unresolved referenced libs. If so, the rootfs build will fail.
    You can override this behaviour with the --autolibs option.
    The configuration file syntax is explained below.


=head1 ARGUMENTS

=item B<--configfile|-c> FILE

    Specify the root filesystem configuration file.
    This is an MANDATORY commandline argument (no default available).

=item B<--searchdir|-s> DIR

    Add a directory to the search path, where to look for files listed in the
    config file.
    This is an MANDATORY commandline argument (no default available).
    Multiple --searchdir options are allowed.


=head1 OPTIONS

=item B<--help|h>

    Print out brief help message.

=item B<--usage|-u>

    Print usage.

=item B<--man|-m>

    Print manual page, same as 'perldoc buildrootfs'.

=item B<--version|-V>

    Print out the program version and exit.

=item B<--verbose|-v>

    Print out useful information about what's going on.
    Multiple --verbose increase verbosity.

=item B<--targetdir|-t> DIR

    Specify the target directory name to create the root file system in.
    The directory is created in the current directory. Defaults to rootfs
    in the current directory.

=item B<--configdir|-C> DIR

    Specify the directory where to search for the series specific
    config files for the rootfilesystem. Defaults to configs
    in the current directory.

=item B<--nochown>

    Disable any chown commands. Changing the ownership of a file
    may require root privilegies, so use this option if you want
    to run this script as normal user.

=item B<--nomknod>

    Disable any mknod commands. Similar to --nochown described above.

=item B<--autolibs>

    Each application is checked for which shared libraries are needed.
    The script then expects those libraries to be listed in the rootfs.conf
    file. The default behaviour in case of a unlisted shared lib dependency
    is to issue an error message and exit. With this option turned on the
    the script will try to find the shared lib within the search path and
    automatically add it to the target directory.

=item B<--noautopath>

    The script will automatically create the complete path to the
    destination directory. This option turns this feature off.
    If you use --noautopath then you have to create the complete
    path to all files via 'dir' entries in the config file.

=item B<--cross> CROSS_COMPILE_PREFIX

    This is used to prefix commands like strip or objdump.
    Default: /opt/mcp/ppcnf/bin/ppcnf-linux-
    You need to specify --cross=native to have no prefix at all!

=item B<--reverse|-r>

    Generate a config file based on a given filesystem tree. If this option
    is given then we read the filesystem tree from --targetdir and write an
    config file to --configfile.
    LIMITATION: Cannot correctly mark files from your own config dir (~C)
		or in general it cannot be determined if a special source
		location is required.
		Does not work for device nodes.

=head1 CONFIG FILE SYNTAX


	The first word determines the remaining parameters and defines
	the type of entry. '#' inidcates an comment line.

	Each line is one entry in the form of either:
	<type> <path> <owner>.<group> <mode> [<source>] [<options>]
	Where:
		<type>    is the type one of: file, bin, lib, mod
		<path>    this is the path in the target rootfs tree.
		<owner>   is the owner.
		<group>   is the group.
		<mode>    is the octal mode of the file.
		<source>  File name to copy the file from. This can be any path,
			  however a leading tilde '~' is substituted by searching
			  with the default search paths.
			  If there is only a '~' as source not followed by anything
			  else this is the same as not specifying any source.
			  However it makes sense to use ony '~' if you want to add
			  one of the <options>.
			  Using '~C' tilde followed by upper case 'C' character
			  then this file is search for only in the configuration
			  directory. This is usefull if the same filename exist
			  in one of the other search paths (eg. a config file
			  that was modified).
			  You can also add a path and filename after '~' that
			  is different than <path> in order to copy a file from
			  one location from the search path to a different one
			  in the target tree. See the Examples below.
		<options> This is a comma separated list of options applied
			  during file system build.
			  Valid options are:
	                  nostrip: Do not strip (Applies to mod, bin, lib line types)
	                  nocheck: Do not check. This means, that this lib is not checked
                                   for any other library/application uses this one (and
                                   so no warning appears when this lib is unused).

	OR
	<type> <path> <owner>.<group> <mode>
	Where:
		<type>  is the type one of: dir, rdir
		<path>  this is the path in the target rootfs tree.
		<owner> is the owner.
		<group> is the group.
		<mode>  is the octal mode of the dir.

	OR
	dev <path> <type> <major> <minor> <owner> <mode>
	Where:
		<path> is the path to the device node (e.g. /dev/null)
		<type> is the type of device node (c for character, b for block, etc)
		<major> is the device major number
		<minor> is the device minor number
		<owner> is the owner
		<mode> is the octal mode of the device nodevice node

	OR
	<type> <path>
	Where:
		<type>  is the type one of: -dir or -file
		<path>  is the path to a directory or filename to be excluded
                        this can only be used if there was 'rdir' type entry.


	OTHER NOTES:

	Available types:
	dir   = directory
	rdir  = recursive directory add
	-dir  = recursive exclude dir from rdir
	-file = exclude file from rdir
	bin   = binary (executable program)
	mod   = loadable module
	lib   = library (shared or static)
	file  = configuration of text file (no library or binary).
	slink = symbolic link
	dev   = device node

	The <path> is a fully qualified file name beginning with /.
	This is the name in the root file system



=head2 EXAMPLES

	mod /lib/drivers/ssi.o bin.bin 644 ~ nostrip,nocheck
	The paramters mean:
	name: name of SSI-DD stored in the root file system.
	bin: id of owner
	bin: id of group
	644: octal file permission setting.
	~: File is copied from /opt/fsp/powerpc-linux/lib/driver/ssi.o
	nostrip,nocheck: options for processing


	Other possible line entries are:
	slink name newname1 newname2 ...


	These entries create a symbolic link. Newname must be a fully
	qualified path name beginning with /.


	bin    /sbin/fspinit root.root 755 ~/usr/bin/fspinit
	Copy fspinit from a search path into /sbin/fspinit in the target
	directory.


	rdir /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers root.root 755
	Add everything underneath the /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers
	directory.


	rdir /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers root.root 755
	-dir  /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers/fsp/tone
	-file /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers/fsp/test/test.ko

	Add everything underneath the /lib/modules/2.6.16.27-0-fsp1/kernel/extra_drivers
	directory but not the fsp/tone directory and not the fsp/fsi/fsi.ko file.




=head1 BUGS



    Report bugs via Bugzilla (FSP Family) on https://bugzilla.linux.ibm.com/


=head1 SEE ALSO

    http://mcweb.boeblingen.de.ibm.com/fsp/wiki/


=head1 AUTHOR

    Harald Freudenberger <freude@de.ibm.com>
    Andreas Loeffler <aloeff@de.ibm.com>

=cut




